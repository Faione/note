# 进程、线程、协程

- [线程与协程](https://zhuanlan.zhihu.com/p/169426477)
- [csos-process](https://hansimov.gitbook.io/csapp/part2/ch08-exceptional-control-flow/8.2-processes))

- [进程、线程、协程](#进程线程协程)
  - [一、进程](#一进程)
  - [二、并发与并行](#二并发与并行)
  - [三、线程](#三线程)
    - [线程的实现方式](#线程的实现方式)
  - [四、协程](#四协程)
  - [五、go语言协程](#五go语言协程)
## 一、进程

- 程序
  - 代码与数据
    - 源代码: c、go等高级语言编辑的文本文件
    - 二进制文件: 源代码通过编译器编译之后所得到, 即一系列机器指令的集合
  - 简而言之，计算机是一个状态机，寄存器中不同的值表示了不同的状态，每条指令的执行驱动着状态机的状态的变化
    - 程序同样是一个状态机，这个状态机是计算机状态机的子集，源代码则是程序员所期望的状态机的描述，是程序状态机的子集

- 进程
  - 经典定义: 一个执行中程序的实例
  - 系统中的每个程序都运行在某个进程的上下文（context）中
    - 内核为每个进程维持一个上下文（context）。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表
  - 进程 = 程序 + 状态
    - 状态即程序状态机中的某一个状态, 这个状态能够通过上下文进行保存
  - 逻辑控制流
    - 单步对程序进行调试，能够看到一系列程序计数器PC的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令，这个 PC 值的序列叫做逻辑控制流，或者简称逻辑流
  - 进程为程序提供的两种关键抽象
    - 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器
    - 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统

## 二、并发与并行

- 并发（concurrency）
  - 一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow），这两个流被称为并发地运行
    - 一段时间里，不同的逻辑流交替执行，表现得像重叠在这段时间上
  - 多个流并发地执行的一般现象被称为**并发（concurrency）**
  - 一个进程和其他进程轮流运行的概念称为**多任务（multitasking）**
  - 一个进程执行它的控制流的一部分的每一时间段叫做**时间片（time slice）**, 因此，多任务也叫做**时间分片（timeslicing）**
  -  并发流的思想与流运行的处理器核数或者计算机数无关, 如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上
- 并行 (parallel)
  -  如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为**并行流（parallel flow）**，它们**并行地运行（running in parallel）**，且**并行地执行（parallel execution）**
  -  并行流是并发流的一个**真子集**

## 三、线程

- 线程
  - 运行在进程上下文中的逻辑流
  - 线程由内核自动调度。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程 ID（Thread ID，TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间
  - 基于线程的逻辑流结合了基于进程和基于 I/O 多路复用的流的特性
    - 同进程一样，线程由内核自动调度，并且内核通过一个整数 ID 来识别线程
    - 同基于 I/O 多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件

- 线程与进程
  - 线程执行是不同于进程的
    1. 因为一个线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多
    2. 线程不同于进程，不按照严格的父子层次来组织
       - 和一个进程相关的线程组成一个对等（线程）池，独立于其他进程创建的线程。主线程和其他线程的区别仅在于它总是进程中第一个运行的线程
       - 对等（线程）池概念的主要影响是
         - 一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止
         - 每个对等线程都能读写相同的共享数据

### 线程的实现方式

- 多对一: 用户态线程
  - 管理线程完全由应用程序(线程库)实现，对OS而言，该程序只是一个单线程进程
  - 进程的执行过程中，每个时刻只有一个线程在运行(并发)
  - 阻塞一个线程，则整个进程阻塞

- 一对一: 内核态线程
  - 管理线程的工作完全由kernel完成(系统调用)，每个用户态的线程都对应与内核态的一个内核线程，绑定TCB
  - 进程的执行过程中，每个时刻可能会有多个线程在运行(并发&并行)


- 多对多: 混合型线程
  - 线程的管理由用户程序与kernel共同完成，一般而言用户创建的线程多于kernel创建的线程，这些线程之间，可以有 多对一 的关系(用户态线程)，也可以有 一对一 的关系（内核态线程），这需要线程库的支持
## 四、协程

- 协程
  - 协程可以看作是用户态线程的一种实现，协程的操作不需要进行系统调用
    - GO协程运行时会交由一个系统线程运行
  - 一个进程中可以有多个线程，一个线程中可以有多个协程
  - 协程完全由程序所控制(用户态)
  - 协程本质是通过I/O多路复用来完成
    - 协程的切换只改变了寄存器和协程栈, 比线程更轻量
  - 线程中的协程的运行是并发的，对于I/O任务，使用协程能够提升线程运行的效率，而对于计算密集型任务，协程无法起到帮助作用，反而由于切换会导致性能降低


## 五、go语言协程



