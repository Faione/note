# 进程与线程

- 单道编程: 同一时刻只有一个线程
- 多道编程: 同一时刻有多个执行线程
  - 虚拟(virtual machine abstraction)
  - 并发(concurrency)
  - 共享(protection)
  - 异步(coordination)
- 通过进程实现
  - 多道并发、隔离保护、资源共享、调度协作

- 程序和进程
  - 进程大于程序: 进程不只有代码和数据
  - 程序大于进程: 一个程序可能有多个同时执行的进程
  - 进程大于程序: 一个进程可以运行多个程序

## 虚拟机制

- CPU虚拟
  - 通过上下文(context)环境实现对CPU的虚拟
- 内存虚拟
  - 通过地址空间(Address)机制实现对内存系统的虚拟

## 进程的内涵与外延

- 进程是一种操作系统对于执行的抽象
  - 执行的实体
  - 系统调度的单位(实际是线程)
  - 程序的动态执行上下文
- 程序执行的实体
  - Register: PC, GPR, FPR
    - 程序指针寄存器，通用整数寄存器，标志寄存器
  - Memory:code, data, stack, heap
- 资源分配的载体
  - 拥有独立的地址空间: memory(address space), file descriptors, file system context
  - 拥有独立I/O状态: file descriptor table, network sockets
- 程序协调的机制
  - 进程间通信IPC、pipe、socket

## 进程管理

- 进程在内存中的表示：PCB，进程队列
  - PCB: 记录进程状态、机器状态(Register,TLB)、调度与统计信息、内存管理信息、I/O
    - Linux中每一个进程都由task_struct数据结构来定义，调用fork()创建进程时，就会产生一个task_struct结构
- 进程管理: 生命周期、状态变迁

## 线程

- 分离进程与进程的执行状态
  - 进程是资源分配的主体，基于进程进行地址空间、内存和I/O的分配
  - 线程是指令执行的主，基于线程管理CPU机器状态、栈执行环境等
- 线程是基本的执行单元，进程实际是线程执行的容器


- 共享部分: 同一进程的所有线程可见
  - 内存状态（全局变量、堆）
  - I/O状态（文件系统、网络连接状态等）
- 私有部分: 线程私有的机器状态
  - 程序执行指针(pc, eip寄存器)
  - 其他CPU相关寄存器
  - 线程执行环境栈: 函数调用参数、临时变量、返回PC
  - 线程ID、信号掩码、errno变量
    - errno: 全局错误码，记录系统调用时的错误
- 资源回收
  - 线程只回收栈
  - 进程回收所有资源
- 线程并发性
