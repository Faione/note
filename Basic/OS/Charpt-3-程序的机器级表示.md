# 程序的机器级表示

## 3.4 访问信息
### 3.4.1 操作数指示符

- 大多数指令有 个或多个操作数 (operand),
  - 指示出执行一个操作中要使用的**源数据值**
    - 源数据值可以以常数形式给出，或是存放在寄存器或内存中
  - 放置结果的**目的位置**

- 操作数通过源数据的来源进行分类
  - 如给出寄存器名称，则源数据就在该寄存器中
  - 我们用符号$$M_{b}[Addr]$$ 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用, 为了简便，我们通常省去下标b

|操作数类型|作用||
|-|-|-|
|立即数|用来表示常数值||
|寄存器|表示某个寄存器的内容|16个寄存器的低位1字节、2字节、4节或8字节中一个作为操作|
|存储器|通过有效地址访问内存相应的位置||

![操作数格式](./img/2022-03-05-10-49-42.png)

### 3.4.2 数据传输指令

- MOV类指令
  - movb、movw、movl、movq
  - 范式：MOV S, D  (D <- S)
- 规范
  - 源操作数指定的值是一个立即数，存储在寄存器中或者内存中
  - 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址
  - x86-64中传送指令的两个操作数不能都指向内存位置，将一一个值从一个内存位置复制到另一个内存位置需要两条指令
    - 将源值加载到寄存器中 -> 将寄存器值写入目的位置
  - movl 指令以寄存器作为目的时，会将该寄存器的高位4字节设置为0

- MOVZ & MOVS
  - 将较小的源值复制到较大的目的时使用
  - MOVZ类指令把目的中剩余的字节填充为0
  - MOVS类指令通过符号扩展来填充

![数据传输指令](./img/2022-03-05-16-37-31.png)

### 3.4.4 压入和弹出栈数据

- push
  - 先改变栈顶，再存数据
- pop
  - 先取数据，再改变栈顶

![入栈与出栈指令](./img/2022-03-05-16-27-49.png)


## 3.5 算数与逻辑操作

- 每个指令都有对应不同大小数据的指令
- 操作风味四组: 加载有效地址，一元操作，二元操作和移位

![算数与逻辑指令](./img/2022-03-05-16-36-52.png)

### 3.5.1 加载有效地址

- leaq(load effective address) 实际是 movq指令的变形
  - 指令形式是从内存读取数据到寄存器，但实际上根本没有引用内存
  - 实际是将有效地址写到目的操作数
  - 目的操作数必须是一个寄存器
  - 编译器中leaq指令的运用更为灵活，即利用其计算地址的范式，来进行一些算数运算

### 3.5.2 一元和二元操作

- 一元操作
  - 只有一个操作数，即使源又是目的
  - 这个操作数可以是一个寄存器，也可以是一个内存位置
  - 如: x++
- 二元操作
  - 第一个操作数是源操作数，第二个操作数即使源又是目的
  - 第一个操作数可以是一个立即数、寄存器或者内存位置，第二给操作数可以是寄存器或捏成位置
    - 若第二个操作数是内存地址，则处理器必须从内存读出值，执行操作，再将结果写回内存
  - 如 x+=y

### 3.5.3 移位操作

- 第一个是移位量，第二个是要移位的数
  - 移位量可以是一个立即数，或者放在单字寄存器%cl中
    - 只允许以此特定寄存器作为操作数
  - 目的操作数可以是一个寄存器或是一个内存位置
- 左移指令有两个名字 SAL 与 SHL，两者效果相同，均是在右边填上0
- 右移指令不同
  - SAR执行算数位移(填上符号位)
  - SHR执行逻辑移位(填上0)

### 3.5.5 特殊的算术操作

- 支持产生两个64位数字的全128位乘积及整数除法的指令

![特殊的算数操作](./img/2022-03-05-21-25-48.png)