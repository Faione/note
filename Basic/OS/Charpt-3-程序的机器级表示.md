# 程序的机器级表示

## 3.4 访问信息
### 3.4.1 操作数指示符

- 大多数指令有 个或多个操作数 (operand),
  - 指示出执行一个操作中要使用的**源数据值**
    - 源数据值可以以常数形式给出，或是存放在寄存器或内存中
  - 放置结果的**目的位置**

- 操作数通过源数据的来源进行分类
  - 如给出寄存器名称，则源数据就在该寄存器中
  - 我们用符号$M_{b}[Addr]$ 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用, 为了简便，我们通常省去下标b

|操作数类型|作用||
|-|-|-|
|立即数|用来表示常数值||
|寄存器|表示某个寄存器的内容|16个寄存器的低位1字节、2字节、4节或8字节中一个作为操作|
|存储器|通过有效地址访问内存相应的位置||

![操作数格式](./img/2022-03-05-10-49-42.png)

### 3.4.2 数据传输指令

- MOV类指令
  - movb、movw、movl、movq
  - 范式：MOV S, D  (D <- S)
- 规范
  - 源操作数指定的值是一个立即数，存储在寄存器中或者内存中
  - 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址
  - x86-64中传送指令的两个操作数不能都指向内存位置，将一一个值从一个内存位置复制到另一个内存位置需要两条指令
    - 将源值加载到寄存器中 -> 将寄存器值写入目的位置
  - movl 指令以寄存器作为目的时，会将该寄存器的高位4字节设置为0

- MOVZ & MOVS
  - 将较小的源值复制到较大的目的时使用
  - MOVZ类指令把目的中剩余的字节填充为0
  - MOVS类指令通过符号扩展来填充

![数据传输指令](./img/2022-03-05-16-37-31.png)

### 3.4.4 压入和弹出栈数据

- push
  - 先改变栈顶，再存数据
- pop
  - 先取数据，再改变栈顶

![入栈与出栈指令](./img/2022-03-05-16-27-49.png)


## 3.5 算数与逻辑操作

- 每个指令都有对应不同大小数据的指令
- 操作分为四组: 加载有效地址，一元操作，二元操作和移位

![算数与逻辑指令](./img/2022-03-05-16-36-52.png)

### 3.5.1 加载有效地址

- leaq(load effective address) 实际是 movq指令的变形
  - 指令形式是从内存读取数据到寄存器，但实际上根本没有引用内存
  - 实际是将有效地址写到目的操作数
  - 目的操作数必须是一个寄存器
  - 编译器中leaq指令的运用更为灵活，即利用其计算地址的范式，来进行一些算数运算

### 3.5.2 一元和二元操作

- 一元操作
  - 只有一个操作数，即使源又是目的
  - 这个操作数可以是一个寄存器，也可以是一个内存位置
  - 如: x++
- 二元操作
  - 第一个操作数是源操作数，第二个操作数即使源又是目的
  - 第一个操作数可以是一个立即数、寄存器或者内存位置，第二给操作数可以是寄存器或捏成位置
    - 若第二个操作数是内存地址，则处理器必须从内存读出值，执行操作，再将结果写回内存
  - 如 x+=y

### 3.5.3 移位操作

- 第一个是移位量，第二个是要移位的数
  - 移位量可以是一个立即数，或者放在单字寄存器%cl中
    - 只允许以此特定寄存器作为操作数
  - 目的操作数可以是一个寄存器或是一个内存位置
- 左移指令有两个名字 SAL 与 SHL，两者效果相同，均是在右边填上0
- 右移指令不同
  - SAR执行算数位移(填上符号位)
  - SHR执行逻辑移位(填上0)

### 3.5.5 特殊的算术操作

- 支持产生两个64位数字的全128位乘积及整数除法的指令
  - 乘法要求其中一个操作数必须在 %rax 中，另一个则作为指令的源操作数给出
    - 乘积存放在寄存器%rdx(积的高64位)和%rax(积的低64位)中
    - 存储乘积到内存需要两个movq指令
  - 除法将寄存器%rdx(高64位)和%rax(低64位)中的128位作为被除数，而除数作为指令的操作数给出
    - 指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中
    - 被除数存放在%rax中，%rdx应设置为全0(无符号运算)或者%rax的符号位(有符号运算)
    - cqto指令: 隐含读出%rax的符号位，并将其复制到%rdx的所有位
![特殊的算数操作](./img/2022-03-05-21-25-48.png)


## 3.6 控制

- 机器代码提供两种基本的低级机制来实现有条件的行为
  - 测试数据值，然后根据测试的结果来改变控制流或者数据流

### 3.6.1 条件码

- 除整数寄存器，CPU还维护一组单个位的条件码(condition code)寄存器，用来对最近的算术或逻辑操作的属性进行描述
  - 检测这些寄存器来执行分支条件命令
- 常用条件码
  - CF: 进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出
  - ZF: 零标志。最近的操作得出的结果为0
  - SF: 符号标志。最近的操作得到的结果为负数
  - OF: 溢出标志。最近的操作导致一个补码溢出, 正溢出或负溢出

- OF溢出标志判断: 加法操作中，操作数符号相同，而结果符号不同

![条件码设置](./img/2022-03-06-09-37-26.png)

- leaq指令不改变任何条件码，其余的算术逻辑指令都会设置条件码
- CMP与TEST类指令也会设置条件码，但仅设置而不改变其他寄存器
  - CMP指令的行为与SUB相同，但只是设置条件码
    - ATT格式中列出的操作数相反
  - TEST指令的行为与AND指令相同，但只是设置条件吗
    - 检测是负数、零还是正数，或进行掩码操作

![CMP与TEST指令](./img/2022-03-06-09-42-13.png)

### 3.6.2 访问条件码

- 条件码通常不会直接读取，常用的使用方法有三种
  1. 可以根据条件码的某种组合，将一个字节设置为0或者1
  2. 可以条件跳转到程序的某个其他的部分
  3. 可以有条件地传送数据

- SET类指令
  - 对于第一种情况
  - setl与setb表示 小于时设置 和 低于时设置，而非指操作数大小
    - cmp第二个操作数 (set) 第一个操作数
  - SET指令的目的操作数是低位单字节寄存器元素之一，或者是一个字节的内存位置
    - 指令会将这个字节设置成0或1，而为得到32位或64位的结果，就必须对高位清零

![SET指令](./img/2022-03-06-09-51-55.png)

### 3.6.3 跳转指令

- 跳转指令会导致执行切换到程序中的一个全新的位置
  - 汇编指令中，跳转的目的通常用一个标号(label)指明
  - 在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标(目的指令的地址)编码位跳转指令的一部分
- jmp指令是无条件跳转
  - 跳转目标可以从寄存器或内存位置中读出
- 其余跳转指令都是有条件的
  - 依赖条件码的某种组合，或者跳转，或继续执行

![JUMP指令](./img/2022-03-06-10-28-12.png)

### 3.6.4 跳转指令的编码

- 汇编代码中，跳转目标用符号标号书写
  - 汇编器以及后来的链接器，会产生跳转目标的适当编码
- 常用编码方式
  - PC-relative(PC相对)
    - 将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码
      - 这些地址偏移量可以编码为1、2或4个字节
      - 即编码时，指令后跟的操作数作为相对位置，通过与小一条指令地址运算，得到新的下一条地址
        - 执行PC相对寻址时，此刻程序计数器的值是 跳转指令 后面的那条指令的地址，而不是当前 跳转指令 的地址，这是因为CPU会将更新程序计数器作为执行指令的第一条指令的第一步
  - 给出"绝对"地址
    - 用4个字节直接指定目标，汇编器和链接器会选择适当的跳转目的编码

- AMD建议在rep后面跟上ret的组合来避免使ret指令称为条件跳转指令的目标

### 3.6.5 用条件控制来实现条件分支

- 汇编器会位 then-statement 和 eles-statement 产生各自的代码块，它会插入条件和无条件分支，以保证能执行正确的代码块

### 3.6.6 用条件传送来实现条件分支

- 实现条件操作的传统方法是通过使用 控制 的条件转移，然而这对于现代处理器来说并不高效
  - 通过条件, 判断程序是否应当执行分支，对于流水线处理器而言，分支预测错误，则会使得流水线之前正在运行的结果失效，这无法发挥流水线的全部性能
- 使用 数据 的条件转移实现条件操作，程序会执行所有可能的结果，只在返回结果时，判断应当返回的值
  - 降低了分支预测错误的惩罚，能够利用流水线性能
- 控制流不依赖于数据，这使得处理器更容易保持流水线是满的
- 使用条件传送指令并非总是能够提高代码效率
  - 如果每个条件分支中的计算量非常大，对应条件不满足时，就会造成浪费
  - 只有当计算量不大时，GCC编译器才会选择使用 条件传送指令 进行优化

![条件传送指令](./img/2022-03-12-10-52-43.png)

### 3.6.7 循环

- C语言中提供的 do-while、while 与 for，在汇编中并不存在对应的指令，而是通过条件测试和跳转组合起来实现循环的效果
  - 条件测试(if语句)，跳转(goto)
  - GCC和其他汇编器产生的循环代码基于两种基本的循环模式

- 理解产生的汇编代码与原始源代码之间的关系，关键是找到程序值和寄存器之间的映射关系

**do-while 循环**

```c++
do 
    body-statement 
    while (test-expr);

// do-while循环可翻译为如下条件和goto语句

loop: 
   body-statement 
    t = test-expr; 
    if (t) 
        goto loop;
```

**while 循环**

- 不同于 do-while， while先判断条件，再执行循环体
  - 跳转到中间
    - 首先执行无条件跳转到结尾的测试，再进行循环
  - guarded-do
    - 首先进行条件分支，若不成立就跳过循环，反之则进行do-while循环

```c++
while (test-expr) 
    body-statement

// 1. 跳转到中间
    goto test; 
loop: 
    body-statement 
test: 
    t = test-expr; 
    if (t) 
        goto loop;

// 2. guarded-do
t = test-expr; 
if (!t) 
    goto done; 
loop: 
    body-statement 
    t = test-expr; 
    if (t) 
        goto loop; 
done:
```

**for循环**

- for循环可以等价转化位 while 循环的形式，因而也能够使用 while 循环同样的翻译方式

```c++
for (init-expr; test-expr; update-expr) 
    body-statement

// 等同于
init-expr; 
while (test-expr) { 
    body-statement 
    update-exp,; 
}

// 1. 跳转到中间
init-expr; 
goto test; 
loop: 
    body-statement 
    update-expr; 
test: 
    t = test-expr; 
    if (t) 
    goto loop;

// 2. guarded-do
init-expr; 
t = test-expr; 
if (! t) 
    goto done; 
loop : 
    body-statement 
    update-expr; 
    t = test-expr; 
    if (t) 
        goto loop; 
done: 
```

### 3.6.8 switch语句

- swich语句能够呢根据一个整数索引值进行多重分支
  - 通过使用跳转表数据结构使得实现更高效
    - 跳转表是一个数组，表项i是一个代码段的地址
  - 相比于 if-else 语句，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关
  - GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句，当开 、关情况数量比较多(例如4个以上)，并且值的范围跨度比较小时，就会使用跳转表
  - "&" 会创建一个执行数据值的指针，在GCC中, "&&" 会创建一个指向代码位置的指针


## 3.7 过程

- 过程是软件中一种很重要的抽象，它提供了一种封装代码的方式，用一组指代的参数和一个可选的返回值，实现了某种功能，然后能够在程序中的不同位置调用这个函数
  - 过程形式多样: 函数(function)、方法(method)、子例程(subroutine)、处理函数(handler)等
  - 主要流程: 传递控制、传递数据、分配和释放内存

### 3.7.1 运行时栈

- C及其他语言进行过程调用的一个关键特性在于使用了栈数据结构提供的后进后出的内存管理原则

### 3.7.2 转移控制

- call 指令能够记录当前指令的执行位置，并唤起另一个函数执行
  - 进行函数的转移只需要设置程序计数器PC的值为将要跳转函数起始位置，但当函数执行完毕进行返回时，处理器必须记录之前函数代码的执行位置
  - 该指令会把返回地址A压入栈中，并将PC设置为将要跳转的函数Q的起始位置
  - 对应的指令 ret 会从栈中弹出地址A，并将PC设置为A
  - 同跳转类似，调用可以是直接的，也可以是间接的，通过 * 声明简介调用
  - 指令后的q用来强调是 x86-64 的调用而非IA32

### 3.7.3 数据传送

- 过程调用除传递控制外，回传控制以外，还包括参数的传递，与结果的返回
  - x86-64中，可以通过寄存器最多传递6个整型(如整数、指针)参数
    - 如果函数有大于6的参数个数，超出6个的部分就需要使用栈来传递
      - 第7个参数位于栈顶，同时所有数据都向8的倍数对齐
- 传递参数时，寄存器的使用有特殊的顺序，同时，寄存器使用的名字取决于要传递的数据类型的大小

![传递参数的寄存器](./img/2022-03-19-14-25-21.png)

### 3.7.4 栈上的局部存储

- 一般来说，过程通过减小栈指针在栈上分配空间，分配的结果作为栈帧的一部分，标号为"局部变量"
  - 寄存器不足够存放所有本地数据
  - 对于一个局部变量使用地址运算符'&'(传入参数时使用 a = func(&b))
  - 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到

### 3.7.5 寄存器中的局部存储空间

- 寄存器是唯一被所有过程共享的资源
- 给定时刻只有一个过程是活动的，但仍必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值
  - x86-64采用了一组统一的寄存器使用管理，所有过程(包括程序库)都必须遵守
    - 寄存器 %rbx %rbp %r12~%r15 被划分为被调用者保存寄存器
      - 被调用者必须保证这些寄存器的值在调用者调用前与被调用者返回后是一样的
        - 被调用者要么不去改变这些寄存器，要么就是把原始值压入栈中，再改变寄存器的值，同时在返回前从栈中弹出旧值
    - 所有其他寄存器，除了栈指针%rsp，都分类为*调用者保存寄存器*，任何函数都可以对这些寄存器进行修改
      - 过程P在这些寄存器中存入某些值，然后调用过程Q，因为Q能够随意修改这些寄存器，所以在调用之前首先保存好这个数据是P(调用者)的责任，故称为 调用者保存寄存器

### 3.7.6 递归过程

- 寄存器与栈的使用规约使得 x86-64 过程能够递归地调用自生，而不用担心变量值错误
  - 每个过程调用在栈中都有自己的私有空间，多个未完成调用的局部变量不会相互影响

## 3.8 数组分配和访问

### 3.8.1 基本原则

```
T A[N]
```

- 数组的声明  
  - 首先，会在内存中分配一个 L*N 字节的连续区域，L是数据类型T的大小(Byte)
  - 引入标识符A，用A作为指向数组开头的指针，指针的值为$x_{A}$
  - 可以使用 0~N-1 的整数索引来访问该数组的元素，数组元素 i 会存放在地址为$x_{A} + L*i$的地方
- 若数组E是int型数组，其地址$x_{E}$存放在 %rdx 中， 索引 i 存放在 %rcx中，要获得元素i的地址，使用指令
  - movl (%rdx, %rcx, 4), %eax
  - 计算$x_{E} + 4*i$, 并将结果存放到 %eax 中
  - 允许的伸缩因子1、2、4、8覆盖了所有基本简单数据类型的大小


### 3.8.2 指针运算

- 整型数组E的起始地址与索引i分别存放在寄存器 %rdx 与 %rcx 中
  - 结果将会存放在寄存器 %eax (数据) 或寄存器 %rax (地址) 中
- 指针之差等于 两个地址之差 除以 该数据类型的大小
  - 只知道地址之差没有意义，同时这样对于指令来说方便实现(只用传送i的值)

![指针运算](./img/2022-03-20-13-02-48.png)