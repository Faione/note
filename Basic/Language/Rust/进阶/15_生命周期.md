# 生命周期

- rust 中每个 reference 存在生命周期
  - 大部分情况下，reference 的生命周期是隐含和推断的, 但如果存在多个 reference，编译器无法进行推断时，则需要进行显示的声明
    - 如多个输入引用，一个输出引用，编译器并不知道输出引用与那个输入关联，为避免悬空指针，需要进行显示地声明
      - 调用处知道引用的生命周期(scope), 由于生命周期的不同，需要让编译器知道返回引用的生命周期与输入引用生命周期的对应关系

## Borrow Checker

- rust 编译器能够检测变量的生命周期
  - 如果 变量指向的内容的生命周期小于其本身的生命周期，则rust能够检测并不允许编译

- 当引用存在多个可能时，编译器无法在编译时进行生命周期的判断，此时无法通过编译

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## Lifetime Annotation Syntax

- 生命周期注释符不会改变reference的生命周期
  - 正如签名指定泛型类型参数时函数可以接受任何类型一样，函数可以通过指定泛型生命周期参数来接受具有任何生命周期的引用
  - 以 `'` 作为起始, 习惯性使用 `'a` ， 类似于 `T`
    - 具体调用时，编译器会选择参数中，生命周期较短的一个，作为参数、返回值的生命周期

- 生命周期注解本身并没有意义，仅仅是告诉编译器，函数的输入参数的生命周期如何相互关联(一样长或不一样长)

```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

- 方法名称后的 `<'a>` 意义类似于泛型

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

- 结构体中的引用同样需要声明生命周期
  - 这样意味着该引用的生命周期不能小于该结构体的生命周期

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

## 省略 lifetime

- rust中，要求使用引用的任何地方都声明生命周期
- 但为编程方便，Borrow Checker 中包含了对于一些情况下的生命周期推断，符合这些情况的可以省略生命周期
  - 这些情况称为 lifetime elision rules

- 第一条规则是作为引用的每个参数都有自己的生命周期参数
  - 编译器认为每个参数都有自己的生命周期 `fn func<'a, 'b>(a: &'a str, b: &'b str)`
- 第二条规则是，如果只有一个输入生命周期参数，则将该生命周期分配给所有输出生命周期参数
- 第三条规则是如果有多个输入生命周期参数，但其中一个是 &self 或 &mut self，因为这是一个方法，则将 self 的生命周期分配给所有输出生命周期参数

- 三条规则都不满足，则编译器会提示错误而无法通过编译

## Static Lifetime

- `'static` 生命周期意味着引用能够在整个程序的整个过程中存在
  - 所有的文字的都是 `'static` ，被编码到代码中



