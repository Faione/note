## 变量内存分配

要打印变量的地址，使用 `fmt.Printf` 函数并使用 `%p` 格式化参数即可。

以下是一个示例代码：

```go
package main

import "fmt"

func main() {
    var i int = 42
    fmt.Printf("i 的地址是 %p\n", &i)
}
```

在Go语言中，局部变量的分配位置（栈还是堆）取决于它们的生命周期和大小。

1. 对于在函数中声明的非指针变量，并且它们的大小是固定的且比较小（通常少于 1KB），它们会被分配在调用栈上。这些变量称作静态生命周期变量。当函数返回时，这些变量就会被自动销毁。

例如，在以下示例中，变量 `i` 和 `j` 的大小是固定的并且很小，因此它们将被分配在调用栈上：

```go
func myFunc() {
    i := 42
    j := "hello"
    // ...
}
```

2. 对于大型或者生命周期不确定的变量，Go编译器将它们分配在堆上。也可以使用指向它们的指针来控制它们的生命周期。

例如在以下示例中，使用 new 函数创建的对象将被分配在堆上，因为它的大小是未知的：

```go
func myFunc() {
    p := new(MyStruct) // p 是指向 MyStruct 的指针
    // ...
}
```

## 变量捕获

在Go语言中，闭包是一种函数值，它可以引用其外部作用域中的变量。在Go语言中，函数是第一类对象，因此可以像其他类型一样传递和使用它们。

当一个函数值（闭包）捕获了外部作用域中的变量时，该闭包会持有对该变量的引用。这些被引用的变量将继续存在于内存中，直到所有闭包不再引用它们为止，并由垃圾回收器进行自动清理。

闭包在捕获变量时遵循以下几个原则：

1. 当一个函数返回一个闭包时，它可以通过捕获变量的方式访问其局部变量。被捕获的变量在闭包生命周期内仍然存在，并且只有闭包可以访问它们。

2. 变量按引用传递，而不是按值传递。闭包引用的变量实际上是指向内存中变量的**指针**，而不是变量本身的副本。

3. 如果一个变量被多个闭包引用，那么它将在内存中保留，直到最后一个闭包不再引用它为止。这是由Go语言的垃圾回收器管理的。

4. 在循环迭代过程中创建闭包时，要特别小心，因为每次迭代都会创建一个新的闭包，并且每个闭包都引用当前迭代中的变量值。如果没有采取适当的措施，可能会导致出现预期之外的行为

## 逃逸分析

[](https://zhuanlan.zhihu.com/p/343562181)