# 动态调度

## 静态调度流水线

- 指令调度
  - 在不改变程序指向结果的前提下，改变指令指向的顺序, 使得相互依赖的指令相隔足够远，从而消除冲突或减少停顿

- 静态调度流水线
  - 完全依赖编译器执行指令调度、硬件完全按照顺序(program order)发射指令的流水线
    - 一旦有指令因资源冲突或数据依赖而停顿，后续指令都不允许发射，即便这些后续指令并不依赖流水线中的任何指令
      - 因此4.1中所讨论的流水线才没有资源冲突、WAR、WAW冲突

- 静态调度流水线存在的问题
  - 对编译器开发人员要求搞
  - 一些依赖关系无法在编译时确定
  - 编译器通用性差(CPU相关)
  - 代码通用性差
  - 受Cache miss影响大
    - cache miss 时，会产生大量停顿
    - 编译器无法知道那些load操作会导致cachemiss
  - 动态调度即让CPU硬件能够取代编译器，自动调度指令的运行顺序

## 动态调度流水线

- 允许就绪指令越过前面停顿的指令，率先投入运行(乱序执行)
  - 就绪指令: 不存在资源冲突、操作数已就绪的指令
  - 就绪指令在ID阶段被阻塞(读寄存器等)
- 将ID阶段拆分为两个阶段
  - Issue
    - 对于未拆分前的ID阶段，但精简操作，只执行必要的事: 指令译码、资源冲突检测
      - 按序执行，停顿在此的指令，同样会阻塞后续指令
      - 不再检测检测所有的数据冲突，无论就绪与非就绪的指令，都有机会发射出去
        - WAR、WAW、RAW冲突不全部检测，但也不意味着都不检测
  - Read Operands
    - 等待数据冲突消除，然后读取操作数
      - 这一阶段检测数据冲突检测数据冲突，也是乱序执行实际发生的位置
      - 非就绪指令会停顿在这一阶段，就绪指令会直接发射出去

- 动态调度流水线引入了指令的乱序执行，这将带来WAR冲突，同时，乱序执行隐含着乱序结束，因此也存在WAW冲突，因此在动态调度流水线中，所有类型的冲突都是存在的


## 计分板算法

- 计分板记录所有必要的信息，控制以下事情
  - 每条指令何时可以读取操作数并投入运行（对应着RAW冲突的检测）
  - 每条指令何时可以写入结果（对应着WAR冲突的检测）
- 计分板算法中，WAW冲突在issue阶段检测，因此仍然会导致流水线停顿

- 每条指令经历四个阶段
  - Issue
    - 