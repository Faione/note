# 指令和流水线冲突

## 基本概念

- 时钟周期:
  - 一个时钟脉冲所需要的时间
  - CPU和其他单片机的基本时间单位, 一个时钟周期内，CPU仅完成一个最基本的动作
- 总线周期:
- 机器周期:
  - 通常用从内存中读取一个指令字的最短时间来规定CPU周期
    - 也即CPU完成一个基本操作所需的时间
  - 多个时钟周期
    - 通常一个机器周期包含12个时钟周期
  - 理解，CPU的实现依靠时序电路，而完成一个指令的各工作周期，都是由一些小步骤组成，而这些小步骤，通过时序电路产生的周期信号实现
- 指令周期:
  - 执行一条指令所需要的时间
  - 多个机器周期
  - 显然，取指译码、间址、执行、中断，一般都是一个机器周期

- [各种周期](https://blog.csdn.net/yelin042/article/details/80878832)



- 流水线
  - 核心价值: 理想情况下，流水线能够实现n倍的吞吐量加速比
    - n为流水线深度
  - 核心问题: 指令直接的依赖关系
    - 指令之间存在数据依赖、控制依赖

### RISC指令集

- RISC: Reduced Instruction Set Computer
  - 数据操作都依赖于寄存器，并且通常会改变寄存器值
  - 只有LOAD与STORE指令会影响到内存，将数据从内存传送至寄存器，或者从寄存器传送数据到内存
  - 指令格式的数量少，并且指令的长度一般相同

- RISC三类指令
  - ALU指令
    - 对两个寄存器操作数（或一个寄存器操作数和一个立即数操作数）进行特定运算，并将结果存入第三个寄存器
  - Load/Store指令
    - 将特定内存位置的数值读入特定寄存器，或将特定寄存器的内容存入特定内存位置
    - 内存位置由一个基址寄存器和一个立即数偏移量指定
  - Branches和Jumps指令
    - 跳转条件通常由两个寄存器的比较结果指定（或一个寄存器同0值的比较结果
    - 目的地址由一个相对于当前PC的偏移量指定

### 指令周期

- RISC指令周期
  - 每条指令最多执行5个周期
    - IF: Instruction Fetch
      - 从存储器读来指令，并准备下一条指令
        - 发送PC至内存，并使得 PC = PC + 4 (32位指令)
    - ID: Instruction Decode/Register Fetch
      - 指令译码，读寄存器堆为ALU准备数据
        - 根据源操作数标识符，从寄存器堆中读取出源操作数
        - 对读取的源操作数进行比较，以为可能的跳转做准备
        - 对指令中的偏移量进行符号扩展
        - 计算可能的跳转目的地址
    - EX: Execution/Effective Address
        - ALU执行数据运算，或计算存储器地址
          - 访存指令: 将基址寄存器和偏移量相加形成访存地址
          - 寄存器-寄存器运算指令: 对读取的2个源操作数执行指定操作
          - 寄存器-立即数运算指令: 对读取的第一个源操作数和立即数执行指定的操作
    - MEM: Memory Access
      - 完成存储器的读或写操作
        - Load: 使用前一个周期计算得到的访存地址读取内存
        - Store: 将数据写入由前一个周期计算得到的访存地址
        - 阶段完成后，数据只是暂存在相应部件中，还需要进一步写入寄存器堆
    - WB: Write Back
      - 写ALU的结果或存储器读出的数据到寄存器堆
        - 对于寄存器-寄存器运算指令和LOAD指令: 将结果写入寄存器文件
  - 显然，当某一条指令处于某周期时，还进入另一个周期时，其他指令不可以进入该周期
    - 如，某指令正在IF，则下一条指令不能执行(指令仍未取到)
- 指令发射
  - 使指令从译码阶段进入到执行阶段

### 流水线

- 在每一个指令阶段启动一条新的指令，就能够实现流水化

- 流水线主要性能指标
  - CPI (Clock cycles Per Instruction)
    - 每条指令运行所需的时钟周期
    - 理想流水线 CPI = 1
  - CR (Clock Rate)
- MIPS（Millions of Instructions Per Second）= CR/CPI
- 影响指令流水线的因素
  - 各级流水线之间的平衡
    - CR
  - 流水线的控制开销
    - CR
  - 指令间的各种冲突(hazard)导致的流水线停顿(stall)
    - CRI CR
- Cpu设计的主要任务
  - 尽可能平衡各流水级的工作
  - 尽可能挖掘指令级并行度（Instruction-level-Parallelism）
  - 减少流水线停顿，降低CPI


## 冲突

### 指令之间的依赖

- 数据依赖(Data Dependences)
  - 两种情形
    - 指令 j 需要使用指令 i 产生的结果
    - 指令 j 数据依赖于指令 k，而指令 k 数据依赖于指令 i
  - 特征
    - 指令之间存在数据流动
      - 这种数据流动既可能通过寄存器发生，也可能通过内存发生
      - 通过内存发生的数据流动更加难以检测，因为两个看上去完全不同的地址表达式（如100(R4)和20(R6)）可能指向同一块内存，而同一个地址表达式所指向的内存却可能随时间发生变化
      - 判断指令之间的数据依赖，需要看指令间是否有数据流动(R1 A -> B)
  - 存在数据依赖的两条指令，必须顺序执行，不能乱序，也不可并行
- 名字依赖(Name dependences)
  - 两条指令使用了相同的*寄存器*名字，或引用了相同的*内存位置*时
    - Antidependence(反向依赖)
      - 后续指令j写入的寄存器或内存位置，恰好由前导指令i读取。这种情况下必须保证指令i读取到正确的值（不能是j写入的值）
    - Output dependence(输出依赖)
       - 两条相邻的指令都想写入相同的寄存器或内存位置。这种情况下，必须保证相关寄存器中最终保存的是后面一条指令的结果
  - 特征
    - 指令之间不存在数据流动
      - 不是真实的依赖可以通过重命名技术解决
- 控制依赖(Control dependences)
  - 控制依赖是指一条指令i同一条分支指令之间的相关性，这种相关性要求指令i只能在应当被执行的时候才被执行
    - 如果一条指令控制依赖于一条分支指令，那么该指令不能被移动到该分支指令前面，从而不再受该分支指令控制
    -  如果一条指令并不控制依赖于一条分支指令，那么它也不能被移动到该分支指令后面，从而受到该分支指令控制
  - 控制依赖并不需要被严格保障，可以再不影响程序正确性的情况下，放松控制依赖，但不允许
    - 例外行为：任何乱序执行都不能改变例外的实际发生
    - 数据流：任何乱序都不能改变指令间的实际数据流动情况

**小结**

- 依赖关系是程序的属性，不依运行它的CPU的结构设计而转移
- 依赖关系有可能导致冲突的发生，也可能不会导致冲突；冲突有可能导致停顿的发生，也可能不会导致停顿。这些是流水线设计方面的问题
- CPU设计人员的主要任务，就是尽可能避免依赖关系演变为冲突，同时尽可能避免冲突造成停顿，从而尽量减少停顿，降低CPI

### 冲突分类

- 数据冲突(Data hazards)
  - 前提: 数据依赖或命名依赖，并且指令相隔过近
    - 顺序(编译顺序): i,j
  - 分类
    - RAW
      - 指令j试图在指令i写入结果之前就读取相应的寄存器或内存位置，从而读取到错误的结果。对应于数据依赖
    - WAW
      - 指令j试图在指令i写入结果之前就写入相应的寄存器或内存位置，从而导致错误的值被保存了下来。对应于输出依赖
    - WAR
      - 指令j试图在指令i读取源操作数之前就写入相应寄存器或内存位置，从而导致指令i读取了更新的值。对应于反向依赖
  - WAW与WAR仅在乱序执行中出现
    - 简单流水线中没有WAW
      - 只有一个写回部件
      - 所有指令的执行时间相同，指令依次发射，因此不可能同时结束
    - 静态流水线中不可存在WAR
      - 不可能存在一条指令执行到WB时，上一条指令还未进入ID

- 控制冲突(Control hazards)
  - 分支指令带来PC取值的不确定性

### 解决冲突

- Structural hazard 
  - 停顿
- Data hazard
  - 前送(forwarding/bypassing)
    - 解决RAW冲突
    - 在结果产生的第一时间送到需要的功能部件中(ALU/DM), 而不是通过寄存器文件来传递
    - 要点
      - 数据前送、多路输出选通器、冲突检测电路
      - 前送相对指令运行的阶段而言，而不是指令的顺序，即前送是硬件的一种机制，能够把当前阶段部件的运算结果前送回上一个阶段的部件中(如WB->EX)
- Control hazard
  - 延迟槽(delayed slot)
    - 为了消除分支指令引入的一个stall
    - 核心思想: 软硬件协同
      - 硬件:分支指令后面那条指令不再作废，而是始终执行（不论前面那条跳转指令是否发生了跳转），这个*指令位置*就叫延迟槽
      - 软件:负责找到一条指令放入延迟槽
    - 延迟槽调度策略
      - 从前导指令中选择
        -  之前的指令，无论分支是否成功，影响都不大
      - 从目的地指令中选择
        - 选择分支成功要跳转的目的地处的指令
        - 即taken情形
      - 从后续指令中选择
        - 选择分支失败要继续执行的指令
        - 即not-taken情形
      - 后两种策略都有可能导致不该执行的指令被执行，因此要求不能有副作用，同时这两种策略都要求编译器能够对分支指令的跳转与否做出预测
  - 分支预测(branch prediction)
    - 在复杂流水线中，尽可能早地知道分支判定结果和跳转地址
      - 分支预测是针对分支判断结果的预测
    - 实现方法: Branch-prediction buffer (branch history table)
      - 区别与静态预测(总是失败或总是成功)
      - 有一个初始状态，预测成功或失败时变更状态，并改变预测策略
        - [分支预测器](https://www.jianshu.com/p/be389eeba589)

## MIPS流水线

### MIPS流水线控制逻辑

- 冲突检测
  - 停顿的实现: 将ID/EX寄存器置零(向后传递空操作)，同时保留IF/ID寄存器
- 数据前送的实现
  - 数据源头
    - ALU的输出(保存在EX/MEM寄存器中)
    - data memory的输出(保存在MEM/WB寄存器中)
  - 数据的目的地
    - ALU的输入
    - data memory的输入


## 复杂流水线结构

- 复杂性主要来自于浮点运算指令
  - 浮点运算指令通常需要运行多拍, 也通常会有多种不同的浮点运算部件
  - 有些部件经过了充分流水化，有些没有
- 两个概念
  - Latency: 一条指令的结果间隔多少周期才能使用
  - Repeat interval(initiation interval): 相同类型指令的最小发射间隔

- 复杂流水线中指令的执行时间不一，因此出现乱序完成(依次发射，但指令的执行不是依次完成)
  - 存在WAW冲突
  - 解决思路
    - 将提前完成的指令的结果先保存在一个缓冲区中，等到前面指令都正常完成后再写入真实寄存器