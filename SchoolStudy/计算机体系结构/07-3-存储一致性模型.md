# 存储一致性模型

## 一、存储一致性定义

- 共享地址空间的存储一致性模型是在多个处理器对存储单元并发读写操作时，每个进程看到的这些操作被完成的序的一种约定

## 二、存储一致性模型分类

### (1)顺序一致性模型

- 顺序一致性(Sequential Consistency)
  - 该模型要求所有处理器的读、写和交换(swap)操作以某种序执行所形成的全局存储器次序，符合各处理器的原有程序次序
    - 即： 不论指令流如何交叠执行，全局序必须保持所有进程的程序
- 所有读写操作执行以某种顺序执行
- 每一个进程的操作以程序序执行

**正确性**

- 正确性标准: 符合程序员的直觉
- 正确性规范: 顺序一致性
  - 对于满足顺序一致性的多处理机中的任一执行, 总可以找到同一程序在单机多进程环境下的一个执行与之对应, 使得二者结果相等
  - 如果在多处理机环境下的一个并行执行的结果等于同一程序在单处理机多进程环境下的一个执行的结果，则此并行程序执行正确

**要求**

- 每个进程按照程序执行序发出存储操作
- 发出写操作后，进程要等待写的完成，才能发出它的下一个操作
- 发出读操作后，进程不仅要等待读的完成，还要等待产生所读数据的那个写操作完成，才能发出它的下个操作
  - 即如果该写操作对这个处理器来说完成了，那么这个处理器应该等待该写操作对所有处理器都完成了
- 第三个条件保证了写操作的原子性
  - 即读操作必须等待逻辑上先前的写操作变得全局可见

**松弛一致性**

- Loads可能会在Loads后重新排序
- Loads可能会在Stores后重新排序
- Stores可以在Stores之后重新排序
- Stores可能会在Loads后重新排序

- 使用提交缓冲区(store buffer)
  - 在早前提交的store指令在内存系统里执行传播时，CPU可以继续执行
  - 由于store缓冲的存在，对于本地load指令可越过store指令提前执行

### (2) 完全存储定序模型

> Total Store Order（TSO）

**要求**

- store操作在store buffer中顺序执行
- load同样按顺序执行，但可穿插到多个store执行过程中
- 若存在一组store->load操作，如果由同一core执行且地址相关，则TSO允许该load操作在store操作完成之前就执行；但如果由多个core执行且地址相关，那TSO要求load指令在store执行完成后才能执行

**不足**

- store->load会存在load结果不确定的情况，此时需要采用同步机制
  - 例如采用原子指令操作以及屏障操作，减少流水线阻塞，疏通store buffer

### (3) 部分存储定序模型

> Part Store Order（PSO）

- 在TSO的基础上放松访问内存访问限制，允许CPU以非FIFO来处理store buffer缓冲区的指令
- CPU只保证地址相关指令在store buffer中以FIFO的形式进行处理，而其他的则可以乱序处理

**要求**

- 同一core中地址不相关的store->store指令可以互相穿插执行
- load按顺序执行，但可穿插到多个store执行过程中

### (4) 处理器一致性模型

**要求**

- 在任一取数操作load允许被执行之前，所有在同一处理器中先于这一load的取数操作都已完成
- 在任一存数操作store允许被执行之前，所有在同一处理器中先于这一store的访存操作（包括load 和store）都已完成

**意义**

- 实际上是把Write Buffer变得让用户可见
  - Store提交后在Write Buffer，还没有写Cache/内存
  - 后面的Load已经从Cache取回数据，此时收到对Load访问Cache行的一个无效请求

- 在实现上的意义
  - 在 Cache 命中的load 指令写回之后但没有提交之前, 如果收到其他处理器对 load 所访问 Cache 行的无效请求,load指令可以不用取消, 较大地简化了流水线的设计
  - 多核龙芯3号处理器设计中就采用了处理器一致性

### (5) 弱存储一致性模型

- 主要思想是把同步操作和普通访存操作区分开来
  - 程序员必须用硬件可识别的同步操作把对可写共享单元的访问保护起来, 以保证多个处理器对可写共享单元的访问是互斥的

**要求**

- 同步操作的执行满足顺序一致性条件
- 在任意普通访存操作被允许执行之前, 所有在同一处理器中先于这一访存操作的同步操作都已完成
- 在任一同步操作被允许执行之前,所有在同一处理器中先于这一同步操作的普通访存操作都已完成
- 即允许在同步操作之间的普通访存操作执行时不用考虑进程之间的相关

**模型**

- 第一点
  - 所有的进程都能以同样的顺序感知到所有对同步变量的访问
  - 当一个进程访问某同步变量时，它会把对该同步变量的访问广播出去，在该进程对该同步变量的操作成功之前，任何别的进程对同步变量的访问都将被阻塞
- 第二点
  - 对同步变量的访问会导致对内存进行刷新的结果
  - 当一个同步访问完成之后，那么所有先前的写操作可以同时确保已完成
  - 当某进程对一个共享数据作了更新之后，它可以通过同步操作将新值传播出去
- 第三点
  - 当一个进程在读一个共享数据(非同步变量)时，通过同步操作，它能获得该共享数据的最新值

### (6) 释放一致性模型

- 对弱一致性模型的改进, 把同步操作进一步分成获取操 作 acquire 和释放操作 release
  - acquire 用于获取对某些共享存储单元的独占性访问权
  - release 则用于释放这种访问权
  - 执行的顺序为：acquire-> load/store ->release

**要求**

- 同步操作的执行满足顺序一致性条件
- 在任一普通访存操作允许被执行之前，所有在同一处理器中先于这一访存操作的ACQUIRE操作都已完成
- 在任一RELEASE操作允许被执行之前，所有在同一处理机中先于这一RELEASE的普通访存操作都已完成

**懒释放与勤释放**

- 勤释放一致性协议在Release操作结束之后，将所有已修改的数据传送给所有别的进程，这样别的进程都拥有此最新数据的一个副本并可在本地访问它们，但实际情况是有可能别的进程并不需要该共享数据，这样就浪费了带宽并给程序带来不必要的延迟
- 懒释放一致性协议在Release操作结束之后，并不急于传送新的数据，而是在别的进程执行Acquire操作之后，由别的进程向它提出获取新数据的请求时，它响应该请求并把共享数据的最新值传送给特定的进程，这样系统的性能又获得了提高

### (7) 单项一致性模型

- 要求编程人员在临界区的开始和结束时使用Acquire和Release操作
  - 但与释放一致性不同的是, 要求每个共享变量都与某同步变量相关联，同步变量可以是锁或者barrier

**优势与劣势**

- 因为只有少量的共享变量需要同步，所以如果将每一个同步变量与多个共享数据相关联，则会减少对同步变量的Acquire和Release操作的开销
- 同时，它还允许多个包含不同变量的临界区并行操作，从而提高了并行性
- 代价主要是每个共享变量均要与一个同步变量相关联，从而带来一些开销及复杂性