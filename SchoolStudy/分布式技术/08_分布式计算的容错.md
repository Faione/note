# 分布式计算的容错

- [分布式计算的容错](#分布式计算的容错)
  - [一、故障类型与故障模型](#一故障类型与故障模型)
    - [(1) 故障模型](#1-故障模型)
  - [二、容错方法和容错涉及方法](#二容错方法和容错涉及方法)
    - [(1) 容错的基本方法](#1-容错的基本方法)
    - [(2) 系统容错的设计方法和原则](#2-系统容错的设计方法和原则)
    - [(3) 分布式系统的故障监测与恢复](#3-分布式系统的故障监测与恢复)

## 一、故障类型与故障模型

- 容错性是指系统的某些组件或子系统出现故障时，依然具备可用性和可靠性
- 分布计算系统的一个重要设计目标是当系统中出现部分失效的时候，系统应该能自动从失效中恢复过来，并且不会对整个系统的性能产生严重的影响

### (1) 故障模型

**分布式系统可信赖性**

- 可用性
  - 可用性反映的是系统随时可被用户使用的特性
  - 也就是说，在任何给定的时刻用户都可以使用此系统正确地执行用户给定的任务
- 可靠性
  - 可靠性指的是在错误存在的情况下，系统持续服务的能力
  - 尽管可靠性和可用性容易混淆，但它们并不是同一个概念
  - 可靠性反映的是**一段时间的特性**，而可用性反映的是**某个时刻的特性**
- 安全性
  - 安全性指的是在系统出现暂时错误的情况下，不出现灾难性后果的能力
- 可维护性
  - 可维护性指的是系统一旦出现故障，系统易于修复的能力
  - 高可维护性的系统意味着具有**高的可用性**
  - 对于高可维护性系统来说，要求它具有自动检测错误和自动修复的能力
- 保密性
  - 保密性要求系统资源不被非法用户访问

**可靠性与可用性的区别**

- 可用性用来描述系统在给定时刻可以正确的工作
  - 系统在每小时中崩溃1ms，那么他的可用性就超过99.9999%，但是它还是高度不可靠的
- 可靠性指系统在可以无故障的连续运行
  - 如果一个系统从来不崩溃，但是要在每年8月中停机两个星期，那么它是高度可靠的，但是它的可用性只有98%

**基本故障模型**

- 故障判断
  - 一个处于故障中的系统不能胜任它所应当提供的服务
- 按故障的时间特性来看，故障可分为
  - 暂时性的(transient)、间歇性的(intermittent)和永久性的(permanent)
- 随机性故障是最严重的故障，也被称为拜占庭故障

<table>
<tbody>

<tr>
<th>故障类型</th>
<th>说明</th>
</tr>

<tr>
<td align=left>
崩溃性故障
</td>
<td align=left>
服务器停机，但是在服务器停机前工作是正常的
</td>
</tr>

<tr>
<td align=left>
遗漏性故障<br>
&nbsp&nbsp 接收性遗漏<br>
&nbsp&nbsp 发送性遗漏<br>
</td>
<td align=left>
服务器对输入请求没有响应<br>
&nbsp&nbsp 服务器未能接收到输入报文<br>
&nbsp&nbsp 服务器未能送出输出报文<br>
</td>
</tr>

<tr>
<td align=left>
时序性故障
</td>
<td align=left>
服务器对请求的响应不是按特定的时间间隔或顺序进行的
</td>
</tr>

<tr>
<td align=left>
响应故障<br>
&nbsp&nbsp 响应值错误<br>
&nbsp&nbsp 状态转换错误<br>
</td>
<td align=left>
服务器的响应是错误的<br>
&nbsp&nbsp 服务器给出了错误的响应值<br>
&nbsp&nbsp 服务器背离了正确的控制流程<br>
</td>
</tr>

<tr>
<td align=left>
随机/随意性故障
</td>
<td align=left>
服务器在随机的时刻产生了一个随机的响应
</td>
</tr>

</tbody>
</table>

**容错分类**

- 故障容错
  - 假设是多节点中可能会存在故障节点，消息会丢失或重复，但是不会有发送假消息的恶意节点，因为都是部署在内网的可控节点
- 拜占庭容错
  - 分布式网络种存在不可控的节点
  - 实用拜占庭容错算法 PBFT

**故障模型**

- 初始死进程
  - 如果在局部算法中没执行过一步，则称进程为初始死进程
- 损毁模型(crash model)
  - 如果进程正确地执行局部算法到某一时刻，此后并不进一步执行，则称它是损毁的
- Byzantine行为(Byzantine behavior)
  - 如果进程执行了与局部算法不一致的任意步，则称进程是Byzantine的
  - 尤其是Byzantine进发送的消息可能包含任意内容

- 健壮算法提出的正确性要求总是指正确进程的局部状态(或者输出)：
  - 初始死进程从不会产生输出，且它的状态总是等于它的初始状态。
  - 如果损毁进程有输出，则它的输出是正确的，因为到损毁发生时，进程的行为是正确的
  - 一个Byzantine进程的局部状态或者输出可以是任意的，任何算法都不满足Byzantine进程的非平凡性要求

**故障模型层次**

- 初始死进程可看作损毁进程的特例
- 损毁进程可看作Byzantine进程的特例
- 容忍损毁要比容忍初始死进程要困难，容忍Byzantine进程更困难
- 健壮Byzantine算法也是健壮损毁算法，健壮损毁算法也是健壮初始死进程算法
- 健壮初始死进程算法的不可能性蕴含着健壮损毁算法的不可能性，而健壮损毁算法的不可能性蕴含着健壮Byzantine算法的不可能性

## 二、容错方法和容错涉及方法

### (1) 容错的基本方法

- 信息冗余
  - 添加额外的位可以发现错误并纠正错误
    - 例如可以在传输的数据中添加一段Hamming码来从传输线路上的噪声中恢复数据
- 时间冗余
  - 执行一个动作，如果需要就再次执行
    - 当错误是临时性或间歇性时，时间冗余特别有用
    - 使用事务就是这种方法的一个例子
      - 如果一个事务中止，那么它就可以无害的重新执行
    - TCP/IP协议中的重传机制，是另外一个例子
- 物理冗余
  - 通过添加额外的装备或进程使系统作为一个整体来容忍部分组件的失效或故障成为可能
    - 物理冗余可以在硬件上也可以在软件上进行
    - 著名的设计TMR（三倍模块冗余，Tiple Modular Redundancy）是经典的硬件冗余，即每个关键模块中的部件都被复制了三份，采用多数表决的方法，确保当某些某块中的单个部件发生故障时，系统还可以正确的运行

### (2) 系统容错的设计方法和原则

- 容错设计将故障视为常规
- 组合的方法
  - 信息冗余、时间冗余和物理冗余的组合应用
- 故障影响面的分析和升级的处理方法

**幂等**

- 前置条件：无
- 原因
  - 不管是业务重试，框架产生的重试，还是网络层重传导致的重试，都有可能让一个请求发送多次
  - 必须保证，一个相同的请求发送2次甚至N次，产生的效果是一样的，不会因为发送了多次产生副作用
- 使用方式
  - 大部分请求都有时效性，同样的请求隔了几个小时再发送过来，大概率是新的业务而不会是导致的重试
  - 因此幂等保证只要在一定时间内，重复的请求你不再消费即可
  - 常用方式是采用一个分布式的缓存，记录请求中唯一标识的requestId或者订单ID，对于每个请求，都判断一下是否有缓存记录，有则直接跳过请求，或者返回第一次消费得到的结果(看上层业务需求)
  - 缓存的超时时间即为请求的有效判断时间

**重试**

- 前置条件：幂等
- 原因
  - 分布式系统中，请求未到达、或者请求失败时，这种失败很有可能是临时的，不是永久的，重新发送请求有可能成功
- 使用方式
  - 重试必须先实现幂等，否则会破坏业务
  - 重试频率一般采用“有限次”、“指数级避退”，同一个请求，成功率是逐次递减的，因此重试的频率也应该逐渐降低，否则会浪费系统资源
  - 重试的次数必须有限，否则容易产生死循环
  - 重试的情况建议列白名单去重试，拒绝没有逻辑的重试

**异步**

- 前置条件：幂等、重试
- 原因
  - 分布式系统中，一个请求可能需要经历好多个节点，请求完成的时间可能会较长，并且受整个集群网络和性能状态影响，请求完成的时间会发生较大波动
    - 这个时间对于系统来说会偏长，但是对于业务来说尚可接受
  - 这个时候如果采用同步的方式调用，会有大量的等待线程，并且伴有大量的超时失败，等待的时候也不知道对方是因为没收到请求没回，还是受到了请求没处理完成没回
  - 但是异步方式，如果请求都没接收到，可以快速重试来保证接收到，这个时候要求已经实现了幂等和重试
- 使用方式举例
  - **请求响应式**，通过rpc框架发送请求后立即返回(一般返回成功则表明对方已经接收到请求)，通过rpc轮询读取结果或者通过发送请求时提供的回调接口返回结果
  - **事件驱动式**，通过kafka等消息中间件，请求方发送请求至消息中间件，被调用方消费中间件的消息跑业务，并且将结果放到消息中间件中，请求发送方也通过消费中间件消息获取结果
  - 实际使用中，这两种方式是综合使用的，比如请求响应式的结果返回可以加上消息中间件作为补偿，也可以直接替换成消息中间件方式

**隔板/隔离**

- 前置条件：无
- 原因
  - 核心逻辑一般是必须要全部成功的，但是有些非核心逻辑，失败了也并不打紧，或者成功一部分即可
  - 这个时候要把这些非核心逻辑和核心逻辑之间进行隔离，或者非核心逻辑之间进行隔离
- 使用方式举例
  - JAVA中常对非核心业务进行分别的try...catch...，一个业务失败时也就打个日志，并不会影响整体业务

**补偿事务**

- 前置条件：隔板
- 原因
  - 一条路不通了，可以试试另外一条路，总之达到目的就行
    - 比如你要发条消息给客户，微信发不通了，试试短信
- 使用方式
  - 业务逻辑中做业务补充即可，做好隔板，某项失败时不要影响整体业务

**降级**

- 前置条件：无
- 原因
  - 降级分为自动降级和手动降级，自动降级部分类似于补偿事务，但是在很多情况下是影响全局的，当检测到问题时，整个系统都对这个业务进行了业务替代
- 使用方式
  - 一种是自动检测并做业务替代，类似于补偿事务
  - 一种是做全局开关，这种开关可以是系统自动打开，或者人工进行打开

**熔断和限流**

- 前置条件：幂等、重试
- 原因
  - 熔断和限流是为了应对性能过载的情形，与其全部业务失败，不如拒绝部分业务，并将剩余业务顺利完成
    - 大部分性能过载是因为一个流量突刺，如果已经设计好了幂等和重试，那么被拒绝的请求将会重新发送过来，那时系统可能已经缓过劲来，可以重新处理请求了
  - 特别是一个集群中，只有一台服务器性能过载的情况，现在集群大部分都通过nginx路由，被拒绝的请求，上层会重新发送并被路由到其他服务器
  - 如果你的系统一直处于性能过载状态，那时只能拓展你的资源，或者从其他架构层面去优化性能了
- 使用方式
  - 通过限制QPS进行判断，单机或者整个集群达到一定QPS时，自动打开限流或者熔断开关
    - QPS可以做很多级别的限制，比如某个接口，或者针对某个调用服务器的外部业务
  - 也可以做手动开关，应对紧急情况

### (3) 分布式系统的故障监测与恢复

- 单机的故障恢复
  - 单机程序可能因为程序bug、宕机等因素导致进程死掉
  - 当进程重启时，往往希望服务能恢复到原来的一致状态
  - 状态的恢复依赖**数据**和**日志**
- 分布式系统的故障恢复
  - 总控节点选择一个新的副本成为主副本进行继续提供写服务即可
  - 总控节点会对下线的节点进行探测，如果一定时间，节点重新可用，则为临时性故障。否则为永久性故障
    - 临时性故障：重新上线的节点需要从其他副本中增量同步这段时间丢失的数据。然后重新提供服务
    - 永久性故障：需要选择一个新的节点，拷贝副本的数据，成为新的副本节点
  - 总控节点也有可能出现故障
    - 目前非P2P的分布式系统基本都是通过强一致性的备机达到HA的效果
    - 多个备机的时候，则可能需要通过选举协议来选择新的总控节点







