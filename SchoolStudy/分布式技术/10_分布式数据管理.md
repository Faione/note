# 分布式数据管理

- [分布式数据管理](#分布式数据管理)
  - [一、一致性模型](#一一致性模型)
    - [(1) 一致性模型补充](#1-一致性模型补充)
    - [(2) 一致性模型小结](#2-一致性模型小结)
  - [二、并发控制](#二并发控制)
    - [(1) 并发控制的目标](#1-并发控制的目标)
    - [(2) 事务处理](#2-事务处理)
    - [(3) 正确性标准](#3-正确性标准)
    - [(4) 基于锁的并发控制](#4-基于锁的并发控制)
  - [三、原子事务处理](#三原子事务处理)
    - [(1) 事务处理分类](#1-事务处理分类)
    - [(2) 原子事务处理实现](#2-原子事务处理实现)
    - [(3) 基于原子事务处理的局部恢复](#3-基于原子事务处理的局部恢复)
  - [四、其他](#四其他)
    - [(1) 分布式提交协议](#1-分布式提交协议)
    - [(2) 分布式系统中的系统数据库](#2-分布式系统中的系统数据库)

## 一、一致性模型

- [一致性模型](05_分布式一致性.md)

### (1) 一致性模型补充

**弱一致性**

- 同步变量
  - 同步变量S相对应的操作只有一个，即同步操作synchronize(S)，该操作用于对所有的数据副本进行同步
  - 一个进程P只对本地数据副本进行操作，当数据被同步时，P进程对数据的最终操作结果才被传播到其他副本上
    - 当然，其他进程对数据的最终操作结果在同步时，会传播到进程P的副本上
- 弱一致性模型是使用同步变量实现的一个一致性模型
  - 访问与数据存储有关的同步变量时，必须遵守顺序一致性模型
  - 以前的所有写操作在每个副本上没有完成之前，对同步变量进行的操作不允许执行
  - 以前的所有对同步变量的操作完成之前，对数据项进行任何读或写操作不允许执行

**释放一致性**

- 在弱一致性模型中，当执行同步操作时，对如下两种情况没有区分
  - 进程完成了写操作，即完成了向其他进程传播写的最终结果
  - 进程要开始读数据，其他进程对数据的更新结果传播到了本地副本上
- 要区分这两种情况，数据存储需要提供对同步变量的两种操作
  - 一种用于应用程序告诉数据存储系统要进入临界区
  - 另一种用于告诉要离开临界区
- 释放一致性为用户提供了这两种同步操作
  - 一种是acquire操作，它用于告诉系统调用进程要进入一个临界区
    - 其他进程对远程副本的修改应该传播到本地，并且要对本地的副本进行更新
  - 另一种是release操作，用于告诉系统调用进程要离开一个临界区
    - 本地进程对本地数据副本的修改应该传播到所有的远程副本上
- 无论采用什么样的方式来实现释放一致性模型，必须遵守如下规则
  - 前面的所有acquire操作完全成功完成以前，对共享数据的读写操作不能执行
  - 在一个release操作被允许执行之前，所有以前的读写操作必须完成
  - 同步变量的访问必须遵守FIFO一致性模型

**数据项一致性**

- 数据项一致性模型同样使用临界区
  - 同释放一致性模型一样，模型要求程序员或编译程序使用acquire原语进入临界区，使用release原语离开临界区
  - 然而，同释放一致性模型所不同的是，模型要求每一个共享的数据项具有一个对应同步变量（例如锁或关卡）
  - 而释放一致性是一类共享变量只有一个同步变量
  - 当对一个同步变量进行acquire操作时，只有被同步变量保护的那些数据才维持一致性

- 这种方法可以减少获得和释放一个同步变量所需的开销，因为只有被这个同步变量保护的少量数据项必须同步
  - 如果多个临界区没有交叉的共享数据，那么这多个临界区可以同时执行，从而提高了并行性
  - 其代价是程序设计变得复杂，并且更容易出错

- 在数据项一致性模型中，同步变量按如下方式使用
  - 每个同步变量有一个当前所有者，所有者进入和退出临界区不必重复地在网络上发送报文
    - 当前所有者就是最后一个对该同步变量执行acquire操作的进程
  - 一个要访问共享数据的进程，如果它不拥有对应的同步变量，它需要向当前的所有者发送一个报文请求获得所有权
  - 多个进程可以以非互斥的方式同时拥有一个同步变量
    - 只能对相应的数据进行读，而不能进行些写

- 数据项一致性模型的数据存储必须符合以下条件
  - 被保护数据的所有更新完成之前，一个进程对相应同步变量的acquire操作不能执行
  - 如果有其他进程持有某个同步变量，即使是以非互斥的方式持有这个同步变量，一个进程以互斥的方式对这个同步变量的访问不能执行
  - 当一个对同步变量的互斥方式访问完成以后，其他进程对这个同步变量的非互斥方式的访问也不能立即执行，除非在这个同步变量的所有者的访问完成之后

### (2) 一致性模型小结

- 不同一致性模型的主要特性

<table>
<tbody>

<tr>
<th>一致性模型</th>
<th>特性</th>
</tr>

<tr>
<td align=left>
严格一致性
</td>
<td align=left>
所有对共享数据的访问操作按绝对时间的顺序排序
</td>
</tr>

<tr>
<td align=left>
线性一致性
</td>
<td align=left>
所有对共享数据的访问操作在每个进程看来是按照同样的顺序执行的<br>
访问操作是按照全局时间戳来排序的<br>
</td>
</tr>

<tr>
<td align=left>
顺序一致性
</td>
<td align=left>
所有对共享数据的访问操作在每个进程看来是按照同样的顺序执行的<br>
但他们的排序不依赖时间<br>
</td>
</tr>

<tr>
<td align=left>
相关一致性
</td>
<td align=left>
所有因果相关的对共享数据的访问操作在每个进程看来是按照同样的顺序执行的
</td>
</tr>

<tr>
<td align=left>
FIFO一致性
</td>
<td align=left>
一个进程内部的所有写操作以它们在该进程中执行顺序被所有其他进程看见<br>
不同进程的写操作在不同进程看来具有不同的顺序<br>
</td>
</tr>

<tr>
<td align=left>
弱一致性
</td>
<td align=left>
只有在一个同步操作执行以后，才可以认为共享数据是一致的
</td>
</tr>

<tr>
<td align=left>
释放一致性
</td>
<td align=left>
当从一个临界区中退出后，共享数据才获得一致
</td>
</tr>

<tr>
<td align=left>
数据项一致性
</td>
<td align=left>
当进入一个临界区时，这个临界区对于的共享数据获得一致
</td>
</tr>

</tbody>
</table>

## 二、并发控制

### (1) 并发控制的目标

- 共享资源，特别是共享信息资源时要求并发活动。并行是并发的一种特殊情况
  - 操作系统中实现的典型并发活动如输入输出操作和计算的重叠是一种并行活动，它能提高执行速度
  - 多个进程在单个处理器上的执行也是一种并发活动，但不是并行活动，它不能提高速度

- 并发控制的目的是在有多个用户的情况下允许每个用户像单个用户那样访问共享资源，多个用户同时访问时互相不干扰

- 并发控制要解决多个用户的活动之间的切换，保护一个用户的活动不受另一个用户的活动的影响，以及对相互依赖的若干活动进行同步等问题
  - 并发控制并不一定能提高速度

### (2) 事务处理

- 数据库管理系统（DBMS）是一个软件系统，负责数据库管理
  - 如果数据库中的数据分布在不同物理节点上，这个数据库就是分布式的
- 数据库中的事务处理是施加在共享数据上的**一组操作**，这些操作是结合在一起的，被当作单个活动看待
- 分布式数据库管理系统由若干个经过网络互连起来的节点组成
  - 每个节点是一个计算机，运行下述两个或其中一个软件模块
  - 事务处理管理员（TM）和数据管理员（DM）
    - TM: 负责管理用户和DDBMS之间的交互作用
    - DM: 管理实际的数据库

- 假定一个DDBMS由四部分组成：事务处理T、TM、DM和数据
  - 事务处理和TM通信，TM和DM通信，DM管理数据
  - TM和TM之间、DM和DM之间不能通信
- 在DDBMS中执行的每个事务处理都由某个TM控制，也就是一个事务处理向此TM发出所有
的数据库操作，为了执行这个事务处理所需要的全部分布式计算都由这个TM进行控制

**TM操作**

- 事务处理T访问DBMS时发出的各种操作的处理过程如下
  - begin
    - TM为T进行初始化，建立一个专用工作空间，这个专用工作空间用来保存从数据库读出的数值或暂存向数据库写入的数值
  - read(x)
    - TM先在T的专用工作空间寻找x的副本，如果存在，则将它返回给T
    - 否则TM向DM发出读命令，从数据库中检索x的副本，并将其值返回给T并存入T的专用工作空间
  - write(x)
    - TM先在专用工作空间检查是否有x的副本，如果有则改成新值，否则创建一个具有新值的x
    - 以上两种情况下，x的新值此时均不存入数据库
  - end
    - TM为每个由T修改的逻辑数据项x向DM发出写命令，请求DM将数据库中x的值改成T的专用工作空间中的新值
    - 全部更新操作执行完毕时T的执行也就结束了，它的专用工作空间也就撤销了

### (3) 正确性标准

- 假定一个事务处理表示一个完整的、正确的计算，每个事务处理如果单独在最初是一致的文件系统或数据库上执行时，将会执行完毕并得到正确的结果，则认为系统的新状态仍然是一致的
- 并发控制正确性标准
  - 用户交给系统的每个事务处理最终将被执行，并最终得到完成
  - 多个事务处理并发执行的结果和这多个事务处理**串行执行**的结果相同

### (4) 基于锁的并发控制

- 依据对象的封锁方式和时间，封锁机制可以分为静态封锁和动态封锁
- 在静态封锁方式中，事务处理在执行操作前，对所有需要的数据对象封锁
  - 这个方法相对简单，然而它限制了并发性，因为有冲突的事务处理必须串行执行
- - 在动态封锁方式中，事务处理在执行的不同阶段对不同对象封锁

**两阶段锁**

- 两阶段封锁的主要内容如下
  - 访问一个对象前先封锁它，为此必须先获得锁
  - 对所有要访问的对象封锁前不对任何对象进行解锁
  - 不要封锁已经被封锁的对象，为此不同的事务处理不可同时获得冲突的锁
  - 事务处理执行结束前，为每个被它封锁的对象解锁
  - 一旦一个事务处理释放一个锁，该事务处理就不能再获得另外的锁
- 每个事务处理锁的过程可分成两个阶段：锁的增长阶段和锁的收缩阶段
  - 增长阶段中事务处理获得所有的锁而不释放任何锁
  - 收缩阶段释放所有的锁而不取得另外的锁


## 三、原子事务处理

- 从用户的角度来看，一个事务处理应该是对数据库进行的一种不可分割的操作，即具有全有或全无的特性
  - 一个事务处理的执行有两种结果，其一是事务处理完全正确地执行完毕
  - 其二是当事务处理夭折或取消时相当于该事务处理根本没有执行，不会对数据库系统有任何影响
  - 具有这种特性的事务处理称为原子事务处理

- 原子事务处理特性
  - ACID

### (1) 事务处理分类

- 平面事务处理
  - 以上我们所讨论的事务处理都是由一系列基本的操作所组成
  - 这种类型的事务处理称为平面事务处理，也称为简单的事务处理

- 平面事务处理具有一定的局限性
  - 平面事务处理的最主要的局限性正是由于它的原子性引起的，由于它不能提交部分结果，对于一个大的事务处理来说，可能会需要执行很长的时间


**嵌套事务处理**

- 一个嵌套事务处理由多个子事务处理组成的
  - 顶层的事务处理产生多个子事务处理，这些子事务处理相互在不同的机器上并行执行
- 每个子事务处理也可以产生自己的子事务处理
- 一个嵌套的事务处理可以用一个树来表示。
- 嵌套事务处理有如下好处
  - 可以提高并发性
  - 可以提高性能
  - 可以提高容错性

**分布式事务处理**

- 分布式事务处理也是由一些子事务处理组成
  - 嵌套事务处理中的子事务处理是将原来的事务处理的工作进行逻辑上的划分得来的，一个嵌套事务处理被分成多层子事务处理，往往是由程序员来划分的
  - 分布式事务处理在逻辑上是平面的，是施加在分布式数据对象上的一系列在逻辑上不可分的操作组成的
- 分布式事务处理的各个操作是由系统根据数据对象的分布情况而分散到不同机器上的
  - 每个机器上的操作组成一个子事务处理，它们是同一个事物处理的参加者

### (2) 原子事务处理实现

- 实现原子事务处理必须提供以下几个组成部分
  - 事务处理管理器
    - 负责使该事务处理的各个参加者就该事务处理是否提交或夭折达成一致意见
  - 恢复管理器
    - 负责在事务处理失效后恢复状态，也就是将未完成或夭折的事务处理的结果作废，对已提交的事务处理要根据坚固存储器的内容完成对数据对象的更新
  - 缓冲器管理器
    - 负责在主存和磁盘间传送数据
  - 运行记录（log）管理员
    - 负责各种操作及状态的记录
  - 锁管理器
    - 负责并发控制
  - 通信管理器
    - 负责透明的跨网络的通信，在分布式事务处理中通知事务处理的管理部分

### (3) 基于原子事务处理的局部恢复

- 用于局部实现事务处理原子性和永久性的技术
  - 意图表、影子页、先写运行记录以及混合方法等

**意图表**

- 意图表方法按顺序完成以下操作
  1. 把事务处理要向各数据对象施加的所有修改操作都存放在一个表中，该表称为意图表
  2. 该表被写入坚固存储器中
  3. 事务处理管理员决定该事务处理是否提交
  4. 若该事务处理提交，则在表中设置完整标志，开始按照意图表修改在磁盘中的那些对象
  5. 删除意图表

**先写运行记录**

- 先写运行记录的方法在事务处理的执行过程中，对数据对象进行了实际的修改
  - 但是在数据对象被修改前，需要在运行记录中写一个记录项，用于告诉事务处理管理员对哪个数据对象进行修改，修改前的值和修改后的值是什么，以便用于失效后的恢复
- 遵守如下规则
  - 在把数据对象的新值写入到运行记录之前，先把数据对象的旧值写入运行记录
  - 在对数据对象进行实际的更新之前，先把该数据对象的旧值和新值写入到运行记录中


## 四、其他

### (1) 分布式提交协议

- 分布式提交用于保证一个进程组中的每一个成员要么都执行某一个操作，要么
都不执行这个操作
- 在分布式事务处理中，分布式提交就是要保证参加同一个事物处理的所有参加
者要么都提交该事务处理，要么都不提交该事务处理
- 分布式提交用于分布式事务处理的全局恢复

### (2) 分布式系统中的系统数据库

- 可以提供一个分布式系统数据库保持全局状态信息
  - 例如进程名字目录、全局文件分类目录、用户权限和账户信息、工作说明符、资源状态等


- 分布式数据库的内部一致性和通常的数据库一样，是指该数据的信息内容而言，包含两个概念
  - 语义完整性
    - 所存储的数据精确地反映该数据库所模仿的客观世界
    - 这要求检验对数据库内容进行修改操作的每个事务处理在提交任何修改前不违背语义完整性的约束
    - 这实际上就是我们前面所提到的一致性约束条件
（2）原子事务处理