## 四、端到端传输

- [四、端到端传输](#四端到端传输)
  - [1 传输层协议概述](#1-传输层协议概述)
    - [1.1 UDP与TCP概述](#11-udp与tcp概述)
    - [1.2 传输端口与多路分解/复用](#12-传输端口与多路分解复用)
  - [2. UDP](#2-udp)
  - [3. TCP](#3-tcp)
    - [3.1 基本概念](#31-基本概念)
    - [3.2 连接](#32-连接)
    - [3.3 滑动窗口](#33-滑动窗口)
    - [3.3.1 功能](#331-功能)
    - [3.3.2 可靠和有序的传输](#332-可靠和有序的传输)
    - [3.3.3 流量控制](#333-流量控制)
      - [(1) 协议](#1-协议)
      - [(2) 示例](#2-示例)
    - [3.3.4 触发传输](#334-触发传输)
      - [(1) 机制](#1-机制)
      - [(2) 糊涂窗口综合症](#2-糊涂窗口综合症)
      - [(3) Nagle算法](#3-nagle算法)
    - [3.3.5 自适应重传](#335-自适应重传)
      - [(1) 丢包检测和重传机制](#1-丢包检测和重传机制)
      - [(2) 自适应重传算法](#2-自适应重传算法)

### 1 传输层协议概述

#### 1.1 UDP与TCP概述
- 用户数据报协议UDP(User Datagram Protocol) [RFC 768]
  - 端到端的、尽力而为的数据报传输服务
    - 把下层网络的主机到主机的传递服务扩展到进程到进程的通信服务
    - 简单异步多路分解与复用：所有应用进程的数据通过传输层传输到IP层，即多路复用；传输层收到的数据交付给相应的应用进程即多路分解
- 传输控制协议TCP (Transmission Control Protocol) [RFC 793]
  - 端到端的、可靠的、面向连接的字节流服务
    - 应用最广泛的传输层协议，占据目前互联网的90%以上流量
    - 多路分解与复用
    - 连接管理：先建立逻辑连接，进行双向数据流传输，通信结束后撤销连接
    - 可靠传输：对一个连接上传输的每个字节编号，通过接收确认和重传来保证可靠传输
    - 流量控制：防止发送方发出的数据超出接收方的接收能力
    - 拥塞控制：防止过多数据注入网络造成网络结点或链路超载

#### 1.2 传输端口与多路分解/复用

传输端口是一种抽象的软件端口
- 应用层的各种协议进程与传输实体进行层间交互的一种地址
- 不同操作系统对端口的具体实现方法不同
- 一般，端口由一个消息队列实现
  - 消息到达时，协议把其加到相应端口队列，队列满，消息被丢弃
  - 应用进程需接收消息时，从队列前端读取一条消息；队列空则进程阻塞直到有消息

端口用16位整数标识
- 仅对单台主机有效，区分本计算机应用层中的各进程
- 进程实际需要通过特定主机的某个端口，即<主机IP，端口号>对，进行标识
  - UDP传输由<主机IP，端口号>二元组唯一标识
  - TCP连接由<源端口号，源主机IP，目的端口号，目的主机IP>四元组唯一标识


### 2. UDP

在ip功能的基础上简单扩充到端到端

### 3. TCP

#### 3.1 基本概念

传输控制协议TCP (Transmission Control Protocol) [RFC 793]
- 端到端的、面向连接的、可靠的、有序的字节流传输服务
  - 面向连接：通信双方先建立逻辑连接，再进行双向数据流传输，通信结束后撤销连接
  - 面向字节流：TCP将应用程序交付下来的数据看做一连串无结构的有序的字节流
  - 点对点的双工通信：每条TCP连接是一对点对点字节流，每个方向一个字节流
    - TCP两端都设有发送缓存和接收缓存，存放双向通信的数据
    - 发送时，应用进程把数据传入TCP的发送缓存，TCP在合适时候将数据发出
    - 接收时，TCP把数据放入接收缓存，应用进程在合适时候读取数据
  - 多路分解与复用
  - 可靠传输：对一个连接上传输的每个字节编号，通过接收确认和重传来保证可靠传输
  - 流量控制：防止发送方发出的数据超出接收方的接收能力
  - 拥塞控制：防止过多数据注入网络造成网络结点或链路超载

#### 3.2 连接

连接建立的三个阶段
- 连接建立
- 数据传输
- 连接释放

三次握手
- SYN只在连接建立时为1, 双方初始发送的数据，序号都随机选择，且不携带数据
  - A: SYN=1, seq=x
  - B: SYN=1, ACK=1, seq=y, ack=x+1
  - A: ACK=1, seq=x+1, ack=y+1
    - 此时可携带数据 

四次挥手
- FIN=1, 说明自己将不再发送数据，但对方不受影响
- FIN报文需要ACK
- 成对的 <FIN, ACK> 表示双方通信的终结

#### 3.3 滑动窗口

#### 3.3.1 功能

- 保证数据的可靠传递
- 确保数据的有序传递
- 增强发送方对接收方的流量控制
  - 接收方根据分配给该TCP连接的缓存数量，动态选择适合的“接收窗口”大小，并通知发送方，使其调整其发送窗口大小，从而改变发送方的发送速率
- 网络拥塞控制
  - 通过改变发送窗口大小控制发送速率，使得发送速率适应网络处理能力的变化

#### 3.3.2 可靠和有序的传输

发送方的TCP：维护一个发送缓冲区
- 存储已被发送应用进程写入但尚未发送的数据、已被发出但未被确认的数据
- 维护三个指针：LastByteAcked、LastByteSent、LastByteWritten
- 发送窗口
  - 发送窗口上限值(MaxWindow) = MIN (CongestionWindow, AdvertisedWindow)
  - 有效窗口(EffectiveWindow) = MaxWindow – (LastByteSent - LastByteAcked)

接收方的TCP：维护一个接收缓冲区
- 存储已到达但是未被应用进程读出的数据，包括
  - 按正确顺序到达已确认、乱序到达未确认的数据
- 维护三个指针：LastByteRead、NextByteExpected、LastByteRecvd
- 接收窗口
  - 根据本地缓存情况，确定AdvertisedWindow大小，并通知发送方，实现流量控制
  - AdvertisedWindow = MaxRcvBuffer – ( (NextByteExpected – 1) - LastByteRead)

选择确认
- 接收方需要对每个收到的数据进行确认
  - 报文段可能乱序到达
- 累积确认(Cumulative ACK) ：对按序到达的最后一个报文段进行确认
  - 简单易实现，但发送方无法确定到底哪些报文段丢失了，应该重传哪些？
- 选择确认(Selective ACK) ：确认接收到的不连续的数据块的边界

区分数据链路层的可靠传输
- 数据链路层的可靠传输提供点对点的可靠传输
  - 应对物理层可能出现的错误 
- 传输层TCP的可靠传输提供端到端的可靠传输
  - 应对网络层IP可能出现的错误 

#### 3.3.3 流量控制

##### (1) 协议

接收方确定AdvertisedWindow大小
- 必须保持：LastByteRecvd – LastByteRead ≤ MaxRcvBuffer
- AdvertisedWindow = MaxRcvBuffer – ( (NextByteExpected – 1) - LastByteRead) 
  - 代表缓冲区中剩余的空间数量
  - 新的数据到达，NextByteExpected 指针右移，窗口大小可能变小
  - 窗口是否缩小依赖于应用进程读取数据的速度与数据到达的速度的相对快慢

发送方根据AdvertisedWindow值确定有效窗口，限制发送速率
- 有效窗口(EffectiveWindow) = AdvertisedWindow – (LastByteSent - LastByteAcked)
- 有效窗口大于0，才能发送更多数据
- 发送方还必须同时保证发送缓存区不溢出
  - LastByteWritten – LastByteAcked ≤ MaxSendBuffer


##### (2) 示例

- 接收方 B
  - 接收进程读取数据的速率小于数据到达速率，每个报文段的到达，都使得AdvertisedWindow变小，直到0
- 发送方 A
  - 得知AdvertisedWindow为0，不再发送任何数据，即使它之前发送的数据被成功确认
  - 发送缓冲区，会因为发送应用进程写入数据，逐渐被填满
  - TCP将阻塞发送应用进程
- 直到，接收方 B
  - 接收应用进程重新开始读取数据，TCP打开通知窗口，即AdvertisedWindow不再为0
- 发送方 A
  - 发送方TCP把数据从它的缓冲区发送出去
  - 当这个数据被确认，释放出相应缓存空间
  - 发送进程结束阻塞，被允许继续执行


#### 3.3.4 触发传输

##### (1) 机制
TCP支持字节流抽象
- 应用程序把字节写到流里 (连接对应的发送缓存)
- 由TCP决定何时从缓存中取出多少字节组成报文段发送

三种触发机制
- TCP 维持一个变量，最大报文段长度 MSS，只要缓存区中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去（空间驱动）
  - 通常把MSS设置为TCP能发送而且不造成本地IP分段的最大报文长度
- 发送进程明确要求TCP发送一个报文段，即 TCP 支持的推送 (push)操作（业务驱动）
  - 应用进程调用push操作，使TCP将发送缓存区中所有未发送字节发送出去
- 发送方的一个计时器到期，就把当前缓存区中所有数据装入报文段发送出去（时间驱动）

##### (2) 糊涂窗口综合症

糊涂窗口综合症 (silly window syndrome)
- 接收进程读取数据速度较慢，接收缓存每当有少量空闲就向发送端确认，打开一个小窗口
- 发送方收到确认后，尽管窗口打开很小，也立刻将允许的窗口用完，发送包含数据很少的报文段
- 小报文段充满网络，传输效率低
  - 极端的例子，接收端缓存已满，每读取一个1字节，确认并打开1字节窗口，发送方收到后再发送1字节，如此以往，每个报文段仅1字节数据，TCP及IP首部至少40字节，传输效率低

##### (3) Nagle算法

Nagle算法
- 若发送方有数据要发送但打开的窗口小于MSS，等待一段时间
  - 等待时间太长，不利于telnet等交互式应用
  - 等待时间太短，发出很多小报文段，导致糊涂窗口综合症
- 引入一个定时器
  - 非基于时钟的定时器
  - 引入自计时 (self-clocking) 方案
    - 将接收方回复的ACK作为激活的定时器，触发传输下一个报文段

当应用产生要发送的数据时
- if  数据和发送窗口≥MSS，或  数据已达到发送窗口大小的一半
  - 立即发送一个报文段
- else
  - if  有报文段正在传输 (包括已传输未确认)
    - 把应用写入的数据字节都缓存起来直到收到对端回复的ACK
  - else  (没有报文段正在传输)
    - 立即发送缓存中的所有数据


#### 3.3.5 自适应重传

##### (1) 丢包检测和重传机制

TCP 每发送一个报文段，就对这个报文段设置一个定时器
- 超时重传时间 RTO (Retransmission Time-Out) 
- 定时器到期，还没有收到确认，就重传该报文段
==

##### (2) 自适应重传算法

原始算法
- 维持一个RTT的平均运行值 EstimatedRTT
- 每次发送报文段记录时间，收到其ACK再次读取时间，二者差值作为样本值 SampleRTT
- 计算新的EstimatedRTT：对旧的EstimatedRTT值和SampleRTT加权平均
  - EstimatedRTT=(1−α)×EstimatedRTT+α×SampleRTT
  - α∈(0,1)，作为平滑系数
    - 取值较大：可跟踪RTT的变化，但受瞬时波动影响大
    - 取值较小：更稳定但不能迅速适应真正的变化
    - 原始TCP规范建议0.8~0.9
- 在此基础上计算超时值 RTO
  - RTO=2×EstimatedRTT

Jacobson/Karels算法
- RTO同时反映出 RTT 和 RTT的变化
- RTO=EstimatedRTT+4×RTTDeviation
  - EstimatedRTT计算方法同原有方法
  - EstimatedRTT=(1−α)×EstimatedRTT+α×SampleRTT 
  - α推荐值为 1/8 
- RTTDeviation计算方法
  - RTTDeviation=(1−δ)×RTTDeviation+δ×|EstimatedRTT−SampleRTT| 
  - δ∈(0,1)，推荐值 1/4

#### 3.3.6 拥塞控制

##### (1) 慢启动

连接刚建立或当判断拥塞发生时，找到合适的发送速率以适应可用资源

发送端设置拥塞窗口CWND, 每个轮次中只发送此轮次开始时CWND允许的报文段
- 每收到一个报文段，CWND+1
- 该轮次CWND报文段都ACK时，开始下一轮发送
  - 显然，此时 CWND = 2*CWND  

##### (2) 拥塞避免

据可用资源的变化如何调整发送速率
使得共享资源的各条流获得相对公平的服务

AIMD加性增，乘性减: 缓和增加而剧烈减少, 能够收敛到最优分配点、
- 加性增
  - 每收到一个报文段, CWND增加 $\frac{1MSS}{cwnd}}$
    - 此处认为每次都发送 MSS 长度的报文段, 1 窗口 = 1 MSS
    - 一个轮次后, CWND + 1
- 乘性减
  - 设置慢启动门限sstresh, 小于门限慢启动，否则AIMD 
  - 若出现timeout, 立刻将cwnd置为1
  - 同时缩小 sstresh = max($\frac{1MSS}{cwnd}}$, 2)


##### (3) 快重传、快恢复

快重传: 收到3个重复ACK后立刻重传
快恢复
- 快重传之后
  - 缩小 ssthresh为当前cwnd的一半
  - cwnd设为新的sshthresh(即立刻进入AIMD)
  - 若恢复过程中出现超时，cwnd=1 







