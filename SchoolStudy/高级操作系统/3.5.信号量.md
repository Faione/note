# 信号量

- [信号量](#信号量)
  - [信号量](#信号量-1)
    - [基本概念](#基本概念)
    - [两种原语操作](#两种原语操作)
    - [信号量中的阻塞](#信号量中的阻塞)
    - [不同的信号量](#不同的信号量)
      - [整型信号量](#整型信号量)
      - [记录型信号量](#记录型信号量)
      - [AND信号量](#and信号量)
    - [信号量集](#信号量集)
      - [信号量vs锁](#信号量vs锁)
    - [Linux信号量实现](#linux信号量实现)
      - [普通信号量](#普通信号量)
      - [读写信号量](#读写信号量)
      - [轻量级的信号量mutex](#轻量级的信号量mutex)
      - [Linux信号量特性分析](#linux信号量特性分析)

## 信号量


### 基本概念

- 信号量: 带睡眠的同步机制
  - 进程尝试获取一个被占用的信号量时，进程会被放入等待队列，并进入睡眠状态
  - 用于对进程执行顺序的控制

### 两种原语操作

- Wait(semaphore): 申请临界资源原语操作(P操作)
  - 等待直到信号量大于1，然后唤醒并使得信号量减1
- Signal(semaphore): 释放临界资源原语操作(V操作)
  - 对信号量加1

### 信号量中的阻塞

- 每个信号量都关联了一个等待进程队列
- 线程调用wait()时
  - 如果信号量open，线程继续执行
  - 如果信号量closed，线程阻塞到等待队列并睡眠
- 线程调用signal()时
  - 如果一个线程在等待队列中，则将线程唤醒
  - 如果没有线程在等待队列， signal会被记录等待下一个线程
    - signal使用一个计数器counter来保存状态

### 不同的信号量

**Binary信号量**

- 取值: 0或1

#### 整型信号量

- 信号量取值: 当前系统该类型临界资源的可用数量
- 设置整型信号量s, s值的含义
  - s>0: 表示系统中空闲的该类临界资源个数
  - s=0: 表示系统中该类临界资源刚好被全部占用，同时没有进程在等待临界资源
  - s<0: S的绝对值表示系统中等待该类临界资源的进程个数

#### 记录型信号量

- s的值是该类临界资源的数量
- L为进程链表指针，指向等待该类资源的PCB队列

```
type semaphore = record
s:integer;
L:list of process;
End
S:semaphore
```

#### AND信号量

- 同时需要多个资源且每种占用一个资源时的信号量操作
  - 将进程运行过程中所需要的所有资源，一次性全部分配给进程
  - 待进程使用完成以后再一起释放
  - 只要有一个资源尚未分配给进程，则其他可能分配的资源也不能分配给它

### 信号量集

- 在AND型信号量集基础上进一步扩展，进程对信号量$S_{i}$的测试值为$T_{i}$，占用值为$D_{i}$
  - $Swait(s_{1}, t_{i}, d_{1};...;s_{n}, t_{n}, d_{n})$
  - $Ssignal(s_{1}, d_{1};...;s_{n}, d_{n})$
- 一般信号量集的几种特定情况
  - Swait(S,d,d)表示每次申请d个资源，当少于d个时，不分配
  - Swait(S,1,1)表示互斥信号量
  - Swait(S，1，0)可作为一个可控开关
    - 当S≥1时，允许多个进程进入临界区
    - 当S=0时禁止任何进程进入临界区
  - 信号量集未必成对使用Swait()和Ssignal(),如一起申请资源，但可以不一起释放资源

#### 信号量vs锁

- 信号量的使用
  - 适用于被占用较长时间的锁
  - 短时间的加锁场景不适合采用信号量
    - 维护等待队列、切换上下文会有开销
  - 信号量只能在进程上下文中使用，不可用于中断上下文
    - 中断上下文不是进程，因此没有睡眠、重调度的状态，而信号量会导致睡眠，这在中断中使用，会导致中断进入睡眠无法唤醒
  - 在获取信号量时，不能拥有自旋锁
    - 获取信号量不成功时，会出现“带锁睡眠”
- 相较于锁
  - 信号量有更多的语义
  - 当信号量大于1，可以允许多个进程同时访问临界资源
  - 当信号量等于1，可以用来做互斥访问

### Linux信号量实现

#### 普通信号量

**数据结构**

- Count: 信号量状态
  - count > 1: 信号量为空闲状态
  - count = 0: 信号量为非空闲状态，没有等待者
- Wait_list: 信号量的阻塞队列
  - 空: 没有等待者
  - 非空: 有等待者

```c
struct semaphore {
    raw_spinlock_t     lock;
    unsigned int       count;
    struct list_head   wait_list;
}
```

**信号量原语**

<table>
<tbody>

<tr>
<th>原语</th>
<th>功能</th>
<th>描述</th>
</tr>

<tr>
<td>up</td>
<td>释放信号量</td>
<td align=left>唤醒阻塞于此的进程</td>
</tr>

<tr>
<td>down</td>
<td>获取信号量</td>
<td align=left>
若不成功，进入UNINTERRUPTIBLE睡眠状态<br>
因为可能导致睡眠，不能用于中断上下文<br>
</td>
</tr>

<tr>
<td>down_interruptible</td>
<td>获取信号量(可被唤醒)</td>
<td align=left>
若不成功，进入INTERRUPTIBLE睡眠状态<br>
可被signal唤醒，在设备驱动中大量使用<br>
因为可能导致睡眠，不能用于中断上下文<br>
</td>
</tr>

<tr>
<td>down_trylock</td>
<td>非阻塞获取信号量</td>
<td align=left>
功能与down类似<br>
但申请不成功时，函数返回，不进入睡眠状态<br>
</td>
</tr>

</tbody>
</table>

#### 读写信号量

- 实现机制
  - 与读写锁类似，读可以并发，写需要独占
  - 内核按FIFO的顺序处理信号量的申请
  - 实现逻辑
    - 当信号量被写进程占用时，所有的其它等待进程进入睡眠
    - 当信号量被读进程占用时，在第一个写进程执行前的所有读进程可以获得信号量

#### 轻量级的信号量mutex

- Mutex
  - Linux中一种精简高效的信号量实现
  - 普通信号量过于通用化和复杂，适用于共享资源数多的情况
  - 一般情况下，采用mutex，除非有特殊限制
- 使用方式
  - 最多一个进程可以拥有mutex:使用数量为1
  - 谁加锁谁解锁: 
    - 加解锁在同一进程中实现
    - 进程不能在拥有mutex的情况下exit(退出) 
  - 不允许递归加锁和递归解锁
  - 不能在中断上下和软中断上下文中使用

- 与spinlock的比较
  - 在**中断上下文中**使用只能使用spinlock
  - 需要在**加锁状态下睡眠**只能使用mutex

**Mutex实现**

- Count的三种状态
  - 1:表示空闲
  - 0:表示上锁
  - 负数：表示上锁，且有等待者

```c
struct mutex {
  atomic_t            count;
  spinlock_t          wait_lock;
  struct list_head    wait_list;
  struct task_struct  *owner;
  void                *spin_mlock;
}
```
 
- 三种执行路径
  - Fastpath
    - 原子性对count减1，如果发现已经占用，进入下个路径
  - Midpath
    - 类似spinlock忙等，要求锁拥有者(owner)很快释放锁
    - 自旋等待者采用MSC锁(by Mellor-Crummey and Scott) 
      - 只有一个等待者会竞争锁，避免Cache回弹(Bouncing) 
    - 避免了频繁睡眠调度的开销
  - Slowpath
    - 锁如果还被占用，则进程睡眠等待

**性能对比**

- mutex在cpu使用率上优于semaphore

#### Linux信号量特性分析

- 开销分析
  - 信号量睡眠、维护等待队列、唤醒等操作都需要耗费时间
  - 信号量适合于需要加锁较长时间的场景
- 适用环境
  - 与用户空间同步，一般只能用信号量
  - 但因为信号量会导致睡眠不能用于中断上下文
- 睡眠限制
  - 可在拥有信号量时睡眠而不会死锁，别的进程会阻塞于此
  - 进程带着spinlock锁不能睡眠
- Semaphore与spinlock、mutex比较
  - semaphore是一种通用机制,mutex有更多的限制
  - semaphore不禁止内核抢占，但spinlock禁止





