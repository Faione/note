# 调度

- [调度](#调度)
  - [一、时钟与定时器](#一时钟与定时器)
  - [二、抢占管理](#二抢占管理)
  - [三、OS调度机制](#三os调度机制)
  - [四、经典进程调度算法](#四经典进程调度算法)
    - [(1) 先来先服务算法](#1-先来先服务算法)
    - [(2) 短进程优先算法](#2-短进程优先算法)
    - [(3) 彩票调度算法](#3-彩票调度算法)
    - [(4) 最高响应比优先算法](#4-最高响应比优先算法)
    - [(5) 时间片轮转算法](#5-时间片轮转算法)
    - [(6) 虚拟轮转算法](#6-虚拟轮转算法)
    - [(7) 多级反馈队列算法](#7-多级反馈队列算法)
    - [(8) 公平共享调度算法](#8-公平共享调度算法)
  - [五、多核与多处理器调度](#五多核与多处理器调度)
    - [(1) 调度](#1-调度)
    - [(2) O(1)调度器](#2-o1调度器)
    - [(3) 2.6.23后内核的调度](#3-2623后内核的调度)
      - [调度策略](#调度策略)
    - [(3) 完全公平调度器](#3-完全公平调度器)
    - [(4) BFS调度算法](#4-bfs调度算法)
    - [(5) Linux多处理器调度](#5-linux多处理器调度)
    - [(6) CPU亲和性调度](#6-cpu亲和性调度)
  - [六、实时调度](#六实时调度)
    - [(1) 实时系统调度](#1-实时系统调度)
    - [(2) 优先级](#2-优先级)
      - [优先级反转](#优先级反转)
    - [(3) 硬实时调度](#3-硬实时调度)

## 一、时钟与定时器

**HZ在jiffies**

- 系统中断的频率:HZ
  - 在编译时静态确定，早期系统为100，现在为250或1000
  - 每秒产生HZ次时钟中断
- HZ对系统的影响
  - 越大:计时精度更高，时钟中断处理开销越大
    - 例如，进程只剩余2ms的时间片，若HZ为100,则可能10ms后才退出执行
    - 若HZ为1000，则可精确在2ms后暂停执行。
- jiffies: Linux中的全局变量
  - 标识系统启动至今的tick数量(时钟中断) 
  - 每秒jiffies增加HZ次
  - 系统启动至今的时间 $秒数 = \frac{jiffies - 预设偏移}{HZ}$
    - 预设偏移offset由内核在启动时设置

## 二、抢占管理

**抢占控制**

- thread_info中的preempt_count
  - preempt_count大于0时，禁止抢占
- 禁止抢占的场景
  - 内核执行中断服务器例程(ISR)
  - 执行软中断或tasklet时
  - 其它设置了preempt_count大于0的操作

**抢占判断**

- 若在禁止抢占期间出现了需要抢占的事件，则在抢占恢复后进行判断，并进行相应调度

## 三、OS调度机制

**核心要素**

- 抢占机制
  - 进程在运行时能否被抢占
  - 抢占的时机
- 调度顺序
  - 以何种优先级顺序选择即将被执行的进程
- 运行时间片
  - 分配给进程的执行时间

**调度器**

- 调度器工作三个步骤
  - 保存当前进程/线程状态
    - PCB/TCB 
  - 选择下一个待运行的进程/线程
  - 分派
    - 加载并跳转到相应PCB/TCB

**资源分类**

- 可抢占资源
  - 可被强制取走，并确定性归还
  - 例如:CPU时间、内存页
- 不可抢占资源
  - 需要自愿放弃
  - 不容易强行取走
  - 例如:磁盘空间
- 不同类型的资源需要采用不同管理机制

**调度机制**

- 进程/线程创建
- 进程/线程退出
- I/O阻塞、同步
- I/O中断
- 时钟中断

**调度准则**

- 最小等待时间(Min Waiting Time)
  - 进程在就绪状态等待获得执行的时间
- 最大CPU利用率(Max CPU Utilization)
  - CPU处于繁忙运行状态的时间百分比
- 最大吞吐率(Max Througput)
  - 单位时间内完成的进程数量
- 最小响应时间(Min Response Time) 
  - 提交后到开始相应的时间
  - 人机交互
    - 需要快速相应，如按下键盘到显示字符的时间
  - 与最小等待时间的区别
    - 考虑中断分派处理等额外开销
- 公平性(Faireness)
  - 以平等方式给系统中每个进程和用户同等的重视
  - 公平性与响应时间的可能冲突
    - 更好的平均响应时间可能出现调度的不公平

## 四、经典进程调度算法

> 周转时间: 作业提交到作业完成所经历的时间, 作业完成时间 - 作业提交时间
> 等待时间: 进程处于等待处理机状态的时间之和
> 响应时间: 提交请求到系统首次产生响应所用的时间


### (1) 先来先服务算法

- 依据进程进入就绪状态的先后顺序执行
  - 一直运行到结束（早期）
  - 一直运行到阻塞或主动放弃CPU
  - 用于非抢占式调度
- 平均响应时间受到达顺序的影响

<table>
<tbody>

<tr>
<th>优点</th>
<th>缺点</th>
</tr>

<tr>
<td align=left rowspan=2>实现简单</td>
<td align=left>平均响应时间波动较大: <br>
短进程(作业)排到长进程(作业)后面</td>
</tr>

<tr>
<td align=left>I/O资源和CPU资源的利用率较低: 
<br>CPU密集型应用导致I/O设备空闲，I/O资源利用率低
</td>
</tr>

</tbody>
</table>

### (2) 短进程优先算法

- 最短时间优先(STCF) 
  - 非抢占
- 最短剩余时间优先(SRTCF) 
  - 抢占
  - 选择就绪队列中剩余时间最短进程占用CPU进入运行状态
  - 就绪队列按剩余时间来排序
- 用历史执行时间来预估未来的执行时间

<table>
<tbody>

<tr>
<th>优点</th>
<th>缺点</th>
</tr>

<tr>
<td align=left rowspan=2>平均响应时间短</td>
<td align=left>可能会造成饥饿: <br>
连续的短进程流会使长进程无法获得CPU资源</td>
</tr>

<tr>
<td align=left>需要预知未来
</td>
</tr>

</tbody>
</table>

### (3) 彩票调度算法

- 动机
  - SRTCF可以保证平均响应延迟，但是不公平
- 彩票方法
  - 给每个作业一定数量的彩票
  - 随机抽取一张中奖彩票(winning ticket)
  - 为了近似SRTCF，给短作业更多的彩票
  - 为了避免“饥饿”，给每个作业至少一张彩票
  - 相互合作的进程可以交换彩票

### (4) 最高响应比优先算法

- 选择就绪队列中响应比R值最高的进程
  - $R = \frac{w+s}{s}$ 
  - w: 等待时间(waiting time)
  - s: 执行时间(service time)
- 在短进程优先算法的基础上改进
- 不可抢占
- 关注进程的等待时间
- 防止无限期等待

### (5) 时间片轮转算法

- 和FCFS算法类似，但是增加了时间片
- 时间片结束时，调度器按FCFS算法切换到下一个就绪进程
- 轮转调度是抢占式调度

- 时间片长度选择
  - RR算法开销
  - 额外的上下文切换
  - 大时间片
    - 等待时间过长
    - 极端情况下退化为FCFS 
  - 小时间片
    - 响应时间快
    - 产生大量上下文切换，影响系统吞吐
  - 经验规则:选择一个合适的时间片，使上下文切换开销处于1%以内

### (6) 虚拟轮转算法

- 引入辅助队列是FIFO
  - I/O密集型经常会进入辅助队列, 而不是就绪队列以备调度
- 引入优先级
  - 辅助队列比就绪队列有更高的优先级

**两种基础的调度算法**

- FCFS先来先服务(First-Come,First-Served) 
  - 早期OS中，待进程执行完毕再进行下一次调度
  - 现在OS中，待进程阻塞或睡眠再触发下一次调度
  - 问题: 后来的短进程容易被前面的长进程长时间阻塞
- RR轮转(Round Robin) 
  - 每个进程公平得到CPU时间配额q，分得1/n的CPU时间
  - 进程的等待时间确定:(n-1)q 
  - 问题
    - q过大,等同于FCFS 
    - q过小，产生交织，带来过多的进程切换开销
  - 经验
    - 典型进程的时间片:10ms – 100ms
    - 典型的进程切换开销:0.1ms – 1ms
    - 因进程切换带来1%的时间损耗

### (7) 多级反馈队列算法

- 设计出发点:难以实现一种算法适用所有的情况
  - 实际的场景需求远比两种基础算法复杂
- 多级队列:原就绪队列被划分区为多个队列
  - 曾在Linux2.4版内核中采用
  - 每个队列有自己的调度算法
  - 交互式进程队列采用RR，后台进程采用FCFS
  - 队列间采用RR,每个队列有其特定的优先级和时间片
- 进程自动在队列间循环移动
  - 等待过久则提升至高优先级队列
  - 独占CPU过久则降低至低优先级队列

**多级队列与优先级**

- 队列之间
  - 每个队列分配一个优先级与相应时间片
  - 队列间按照时间片调度

**多级反馈队列MLFQ**

- 进程可在不同队列间移动的多级队列算法
- 特征
  - 时间片大小随优先级级别增加而增加
  - 进程在当前的时间片没有完成，则降到下一个优先级
  - CPU密集型进程的优先级下降很快，I/O密集型进程停留在高优先级

### (8) 公平共享调度算法

- FSS控制用户对系统资源的访问
  - 一些用户组比其他用户组更重要
  - 保证不重要的组无法垄断资源
  - 未使用的资源按比例分配
  - 没有达到资源使用率目标的组获得更高的优先级

## 五、多核与多处理器调度

- 设计问题
  - 进程/线程到处理器分配
- 协同调度(co-scheduling) 
  - 一个进程的多个线程共同运行
  - 一个应用的多个进程共同运行
- 专用的处理器分配
  - 线程会在一个专用的处理器上运行直到完成

### (1) 调度

- 单队列多处理器调度
  - 缺乏可扩展性
  - 缓存亲和性弱
  - 尽可能让进程在同一CPU上运行，保证缓存亲和性，可能会牺牲其他进程的亲和度来实现负载均衡
- 多队列多处理器调度
  - 每个CPU调度之间相互独立，避免单队列中数据共享及同步带来的问题
  - 可扩展性强
  - 良好的缓存亲和度（进程可以绑定在特定CPU上）
  - 负载不均衡，怎么解决？
- 负载不均衡问题
- 通过工作窃取，来发起进程迁移
  - 通过检查其他队列的进程数，来判断是否前一
  - 检查太频繁——较大开销，可扩展性差
  - 检查间隔太长——负载不均

### (2) O(1)调度器

- 设计动机
  - 为唤醒、上下文切换、定时器中断开销建立O(1)的调度器
- 进程有140种优先级，可使用长度为140的数组记录优先级

- 基于nice值的固定时间片轮转调度算法
- 改善交互性能
  - 在高负载情况下仍能够快速响应
  - 自动判断出交互进程并动态提高优先级
    - 通过bonus实现动态优先级
  - 避免进程饿死
- 扩展性良好
  - O(1)的调度时间复杂度
  - 负载均衡:当有负载时不会有CPU空闲
  - CPU亲和性:不会出现进程随机在CPU间切换

**静态优先级**

- 静态优先级优先级取值范围`[1,139]`
  - 值越低优先级越高
  - `[100,139]`保留给普通进程:SCHED_NORMAL
  - `[1,99]`留给实时进程:SCHED_FIFO、SCHED_RR 
- 静态优先级与时间片是直接对应关系(ms)
  - If(static_priority < 120) time_slice = (140-static_priority) * 20 
  - If(static_priority >= 120) time_slice = (140-static_priority) * 5

**动态优先级**

- 动态优先级用于进程抢占的判断
  - 高优先级总是比低优先级先执行
- 动态优先级在调度器选择新进程时计算
  - 取值最大为100，因此其不可能超越实时进程的优先级
  - 动态优先级值由静态优先级换算
- 动态优先级的换算关系
  - Dynamic priority = max(100， min(static priority –bonus + 5, 139)) 
- bonus取值范围为`[0,10]` 
  - bonus小于5代表惩罚，大于5代表奖励
  - 睡眠时间越长，bonus越大

**Runqueue**

- 两个优先级队列数组
  - 活跃(Active)与过期( expired) 
  - 一共140个优先级`[1,140]`
  - 数字越小，优先级越高
- 进程饿死问题解决办法
  - O(1)中的Active与Expired队列
  - 时间片用完后，从active转到Expired队列，让低优先级进程有机会运行

**O(1)调度器调度过程**

1. 从活跃队列数组中找到最高优先级的非空队列
   - 如果为空，则交换活跃队列数组与过期队列数组
2. 从选择的队列中找到第一个进程
3. 调整该进程的优先级
4. 切换到该进程执行
5. 当进程用完时间片，则将该进程插入过期队列数组中的对应队列，并调用schedule进行下一次调度

- 优势
  - 交换活跃数组和过期数组，给低优先级进程运行机会
  - 防止饿死
- 时间复杂度低: O(1) 
- 只在开始运行和结束运行时涉及进程相关数据的访问

**最高优先级队列查找**

- 时间复杂度低: O(1)
  - 只依赖与优先级的数量
  - 与系统中的进程数量无关
- 实现 -> bitmap 用于快速查找
  - 140个queue只需要5个integer进行表示
    - O(1)表示复杂度为常量，与进程个数无关
  - 从中查找第一个非零位
  - 硬件指令可以完成这种查找
    - Bsfl on x86

**O(1)轮转调度器问题**

- 不易区分CPU受限和I/O受限
  - I/O受限需要更好的交互性
  - CPU受限需要保持较长的CPU执行时间
- 很难确定合适的时间片
  - 太小:对I/O密集合适，但太多的进程切换开销
  - 太大:对CPU密集合适，但交互性受损
- 将时间片直接对应优先级存在问题
  - I/O 受限进程希望低优先级，但时间片短
  - CPU 受限需要高优先级，但时间片长
- 优先级是相对的，但时间片却是绝对的
  - Nice 0和1，时间片为100和95ms: 5% 差异
  - Nice 19和20，时间片为10和5ms: 100%差异

### (3) 2.6.23后内核的调度

- 基本给概念: 调度类(scheduler class)、调度策略(scheduling policy)、优先级(sched_priority)

#### 调度策略

- 相关系统调用：设置进程的调度策略
  - sched_setattr

<table>
<tbody>

<tr>
<th>调度类</th>
<th>调度策略</th>
<th colspan=2>调度算法</th>
</tr>

<tr>
<td align=left rowspan=2>实时类</td>
<td align=left>SCHED_FIFO</td>
<td align=left colspan=2>First in-first out scheduling</td>
</tr>

<tr>
<td align=left>SCHED_RR</td>
<td align=left colspan=2>Round-robin scheduling </td>
</tr>

<tr>
<td align=left rowspan=2>普通类</td>
<td align=left>SCHED_OTHER</td>
<td align=left rowspan=2>采用CFS调度算法</td>
<td align=left>缺省的分时共享进程</td>
</tr>

<tr>
<td align=left>SCHED_BATCH</td>
<td align=left>批处理，CPU密集型进程</td>
</tr>

</tbody>
</table>

**SCHED_FIFO调度策略**

- 抢占策略
  - 抢占任何采用SCHED_OTHER、SCHED_BATCH等非实时策略的进程
- 优先级(sched_priority)
  - 取值范围`[1,99]`，值越大优先级越高
- 时间片
  - SCHED_FIFO进程没有时间片的概念，只会被更高优先级的进程抢占
- 生命周期
  - SCHED_FIFO进程变得可执行时，会被插入对应优先级队列的队尾，按先后顺序进行执行
  - SCHED_FIFO进程会一直运行，除非下面某种情况发生
    - IO阻塞
    - 被更高优先级进程抢占
    - 调用了sched_yield

**SCHED_RR调度策略**

- SCHED_RR是对SCHED_FIFO的一个简单升级
  - 所有SCHED_FIFO的机制都适用于SCHED_RR，除 了❖ 每个SCHED_RR进程只能运行有限的时间片
  - 时间片一般为100ms
- 相关系统调用
  - sched_rr_get_interval(2)
  - 用于获取SCHED_RR时间片

**非实时调度策略**

- SCHED_OTHER:缺省的Linux分时调度策略
  - 适用于所有不要求实时机制的进程
  - SCHED_OTHER进程的优先级不参与优先调度决策
  - SCHED_OTHER进程的优先级只影响衰减因子
- SCHED_BATCH:批处理
  - 类似于SCHED_OTHER
  - 假定进程是CPU密集型的
  - 调度优先级略低于SCHED_OTHER

**相关命令**

- ps命令:可用于查看进程的调度策略

```shell
$ ps -e -o class,cmd | grep sshd
```

- chrt命令:可查看修改实时调度策略与优先级

```shell
$ chrt -p 1836
```

### (3) 完全公平调度器

- 建立一个理想的处理多任务CPU模型
  - N个进程，每个进程执行在1/N速度的CPU上
- 核心思想
  - 动态调整时间片和执行顺序
- 不对每个进程采用固定的时间片
  - 相反，在所有进程间采用固定时间片
- 不采用固定优先级选择下一个任务
  - 将已运行时间作为调度选择的依据
  - 选择最少运行时间的进程
  - 等同于动态优先级

**CFS调度器的优先级与时间片**

- CFS 定义了一个调度延时(sched_latency) 
  - 也称为目标延时(targeted latency) 
    - 近似于所有进程的总时间片
    - 获取和设置命令 `sysctl kernel.sched_latency_ns`
  - 保证在调度延时内，每个进程至少可以得到一次执行
  - 进程最大等待时间不超过调度延时，缺省调度延时为`6ms`
- 时间片根据进程权重占调度延时的比例确定
  - $进程时间片 = \frac{ 调度时延迟 \times 进程权重}{所有进程权重之和}$
  - 权重相同时:Timeslice(task) = 调度延时/进程数
  - 最小时间片粒度(sched_min_granularity)，缺省为`0.75ms`
    - 查看命令 `$sysctl kernel.sched_min_granulariry_ns`
- 当进程数过多，且无法在缺省调度延时内为每个进程分配最小粒度时间时，则调度延时调整为
  - $sched_latency = 进程数 \times 最小时间片粒度$

**nice值与权重weight**

- 每个进程都有自己的Nice值
  - 取值范围`[-20,+19]`，值越小，优先级越高，缺省值为0
  - 进程的Nice值越小，可获得的CPU时间越多
  - Nice值的设定
    - 普通用户可以为进程分配大于`0`的nice值
    - Root用户可以分配小于`0`的nice值
- Nice值的权重
  - 如nice值`-20`的权重为`88761`，nice值`0`的权重为`1024` 
  - nice值每增加`1`，所获取的CPU时间资源减少`10%`
  - nice值到weight的映射采用了数组
    - 每个nice值有一个对应的数组项表示权重
- Nice与时间片的关系
  - 任务获得的CPU时间由其Nice值权重的相对占比确定，不再像对应O(1)调度器中对应绝对时间
  - 高优先级任务不再长时间阻塞低优先级

**进程选择**

- 策略:选择当前最小加权运行时间的进程
- 虚拟运行时间vruntime(Virtual run time) 
  - 由nice值进行加权的实际运行时间
    - 因为加权，Vruntime并不与实际的运行时间一致
  - 高nice值(权重小)会到导致进程得到的cpu时间资源越少
- 示例:假如某进程运行了200ms
  - Nice = 0: vruntime = 200ms
  - Nice < 0: vruntime < 200ms
  - Nice > 0: vruntime > 200ms 
- Nice值越小，vruntime值减少越慢

**Vruntime值的计算**

- 衰减因子(decayfactor) = $\frac{weight_{0}}{weight_{i}}$
  - 其中$weight_{0}$是nice值0的权重
  - $weight_{i}$是nice值i的权重

- $\Delta vruntime= 当次实际CPU时间 \times 衰减因子$
  - 每次进程退出执行时，对进程的vruntime变量加上相应增加额
  - 衰减因子越小，实际的vruntime时间越少

**进程选择**

- 选择最近最少运行时间的进程
  - 由vruntime变量跟踪
  - 每次进程运行t纳秒
    - vruntime += t (weighted by process priority) 
- 如何影响I/O受限和CPU受限进程
  - 任务A: 每100秒需要1毫秒的执行 (I/O受限) 
  - 任务B, C : 每100毫秒需要80毫秒的执行(CPU受限) 
  - 经过10次后
    - Vruntime(A) = 10, vruntime(B,C)=800
    - A 获得了优先级, 但B和C获得了更大的时间片(每个10ms) 
- 问题: 如何有效找出最小的vruntime值?
  - 调度需要高效实现这个查找
  - 简单遍历所有进程将是低效的O(N)复杂度操作

**vruntime与进程管理**

- 通过红黑树对进程进行管理
  - 平衡二叉搜索树(Balanced binary search tree) 
  - 以vruntime作为键值进行排序
    - 插入、删除、更新: $O(\log N)$
    - 查找最小值: $O(1)$
  - min_vruntime 缓存最小 vruntime
- 更新 vruntime 和 min_vruntime 的时间
  - 每次新任务加入或删除时
  - 每个时钟周期，每次进程切换

**小结**

- 公平性
  - 系统负载极重时，也能保证确定的响应时间和运行时间
  - 低优先级任务也能得到关注和执行
- 适应性
  - 自动识别I/O密集和CPU密集
    - I/O进程被唤醒时自动优先得到调度
- 实现性
  - CFS设计简洁，性能够用 $O(\log N)$

### (4) BFS调度算法

- BFS是一种时间片轮转算法的变种
  - 在多处理器情况的单就绪队列（双向链表）选择，增加了队列互斥访问的开销
  - 但减少了负载均衡算法开销

**就绪队列**

- 线程优先级：103个优先级
  - 100个静态的实时优先级
  - 3个普通优先级
    - SCHEDISO（isochronous）
    - SCHEDNORMAL
    - SCHEDIDLEPRIO（idle priority scheduling）
- 单就绪队列
  - 所有CPU共享一个双向链表结构的单就绪队列
  - 所有线程按优先级排队
  - 相同优先级的每个线程有一个时间片长度和虚拟截止时间

**虚拟截止时间**

> Virtual Deadline

- 时间片由算法参数指定
  - 可在`1ms—1000ms`间选择，缺省值为`6ms`
- 是一个就绪队列中线程等待CPU最长时间的排序
  - 不是真实的截止时间
  - 线程时间片用完，重新计算VD，插入就绪队列
  - 事件等待结束时，VD保持不变，以抢先低优先级线程或插入就绪队列
  - 不同CPU对线程的VD加一个权重——从而让线程在上次运行的CPU上执行，保证缓存亲和度
- 依据当前时间、线程优先级和时间片计算
  - $offset = jiffies + (prior_atio \times rr_interval)$
  - nice每提升一级，prior_atio 增加10%

### (5) Linux多处理器调度

- 每个CPU一个runqueue
  - 为防止出现负载不均衡，需要对运行队列进行再平衡
    - 内核线程Migration thread负责将进程从一个队列移动至另一个队列
  - 为防止死锁
    - 内核按相同的顺序对runqueues进行加锁
- 负载均衡的调用时机
  - 当出现某个队列没有可运行的任务时，会主动调用 load_balance
  - Load_balance 也可以通过定时器周期性被调用
  - 当系统空闲时，每个tick都会被调动
  - 或者每100ms进行一次负载均衡

### (6) CPU亲和性调度

- 每个进程都有一个bitmask位表示其能够运行的CPU 
  - 缺省情况下是所有CPU 
  - 进程可以改变bitmask 
  - 子进程从父进程继承该掩码，父子进程运行在同样的CPU上
- 负载均衡并不改变亲和性
  - 不能将进程调度至掩码以外的CPU上
- 实践
  - Taskset命令
  - `Taskset -p mask PID`
- NUMA调度
  - NUMACTL相关系统调用

## 六、实时调度

- 两种类型的实时
  - 硬实时(hard deadline) 
    - 必须满足，否则会导致错误
  - 软实时(soft deadline)
    - 大多时候满足，没有强制性

### (1) 实时系统调度

- 系统设计机制挑战
  - 系统延时会影响实时保证性
  - 中断时延:硬件中断触发到开始执行中断服务例程的时间
  - 派发时延:选择并切换至对应进程执行的时延
- 策略
  - 保证优先级高的任务得到优先执行
  - 保证硬实时进程能在deadline时间前完成

### (2) 优先级

- 每个进程会对应一个优先级
  - 总是选择最高优先级的就绪进程(可能会阻塞) 
  - 在相同最高优先级的进程间进行轮转
  - 可能会抢占或被抢占
- 表达优先级
  - 以整数表达，越大越高或相反
- 设置优先级
  - 静态设置
    - 一些任务总是比其它任务拥有更高的优先级
    - 问题:饥饿 
- 动态优先级由操作系统调度
  - Aging: 当在就绪队列中等待过久则提升优先级

#### 优先级反转

- 高优先级的进程可能会依赖低优先级进程


**优先级继承**

- 继承其等待进程中的最高优先级
- 对各个进程的优先级进行链表管理
- 依赖关系解除时，进程可以恢复到原始状态
- 占用资源的低优先级进程继承申请资源的高优先级进程的优先级
  - 只在占有资源的低优先级进程被阻塞时, 才提高占有资源进程的优先级

**优先级天花板协议**

- 占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同
  - 不管是否发生等待,都提升占用资源进程的优先级
  - 优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会被阻塞

### (3) 硬实时调度

- 硬实时:必须满足截止完成期限
- 进程特性:周期性需要得到执行
  - 处理时间t, 截止完成期限 d, 周期 p
  - 0 ≤ t ≤ d ≤ p
  - 任务的周期律为 1/p

**单调速率调度**

- 适用于周期性进程，基于进程周期静态设定优先级
  - 优先级按照周期倒数进行分配，周期越短则优先级越高

**最早截止时间优先**

- 优先级根据截止时间确定
  - 越早的截止时间，越高的优先级
  - 动态优先级: 进程在不同时刻可以有高低不同的优先级
    - 并不需要进程有周期性
    - 也不需要预先知晓所需要的CPU处理时间
    - 是最优的动态调度算法，但需要知晓截止时间