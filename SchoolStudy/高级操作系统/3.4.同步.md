# 同步

- [同步](#同步)
  - [一、基本概念](#一基本概念)
  - [二、临界区和原子操作](#二临界区和原子操作)
    - [(1) 操作系统中的原子操作](#1-操作系统中的原子操作)
  - [三、内存屏障](#三内存屏障)
    - [(1) 屏障原语](#1-屏障原语)
  - [四、锁](#四锁)
    - [(1) 使用锁](#1-使用锁)
    - [(2) 自旋锁](#2-自旋锁)
      - [禁用中断以实现互斥](#禁用中断以实现互斥)
      - [原子操作指令](#原子操作指令)
      - [基于软件方法的忙等待](#基于软件方法的忙等待)
      - [小结](#小结)
    - [(3) 读写自旋锁](#3-读写自旋锁)
      - [设计与实现](#设计与实现)
      - [seqlock](#seqlock)
      - [RCU](#rcu)

## 一、基本概念

**并发冲突**

- 定义
  - 两个或两个以上执行主体对共享资源的冲突性竞争访问
  - 导致执行结果不可预知，甚至对系统运行产生破坏性影响

- 产生并发冲突的条件
  - 资源共享条件
  - 时间重叠条件
  - 状态更改条件: 至少一个访问改变资源状态或影响其他访问结果

**解决并发冲突**

- 破坏资源共享条件
- 破坏时间重叠条件
  - 打乱时间重叠的执行次序
  - 单核系统中，禁用中断，消除可能的进程执行交叉
  - 全局锁

- 主要技术

<table>
<tbody>

<tr>
<th>技术</th>
<th>方式</th>
<th>原理</th>
</tr>

<tr>
<td>Per-CPU变量</td>
<td align=left rowspan=2>
将共享资源split为非共享资源
</td>
<td rowspan=2>
破坏资源共享条件
</td>
</tr>

<tr>
<td>资源静态划分</td>
</tr>

<tr>
<td>原子操作</td>
<td align=left>
通过原子操作分割并发访问
</td>
<td rowspan=2>
破坏冲突的时间重叠
</td>
</tr>

<tr>
<td>内存屏障</td>
<td align=left>
限制全局的内存访问顺序
</td>
</tr>

<tr>
<td>锁、信号量</td>
<td align=left>
通过锁协调机制，分离访问
</td>
<td rowspan=3>
破坏冲突的时间重叠
</td>
</tr>

<tr>
<td>RC锁</td>
<td align=left>
通过指针实现无锁访问 
</td>
</tr>

<tr>
<td>禁止中断、软中断</td>
<td align=left>
通过禁止中断，避免并发执行
</td>
</tr>

</tbody>
</table>

## 二、临界区和原子操作

**临界区**

- 临界资源
  - 两个或以上的进程不能同时使用的资源
- 临界资源的访问

```
repeat
    进入区
    临界区
    退出区
    剩余区
until false
```

**进程的同步与互斥**

- 互斥
  - 进程之间由于竞争同一资源而产生的相互制约关系，称为进程的互斥
  - 两个或两个以上进程必须互斥的使用临界资源
- 同步
  - 有协作关系的进程之间不断地调整它们之间的相对速度和执行过程，以保证临界资源的合理利用和进程的顺利执行
  - 借助一个中间媒体来实现，如信号量、加锁操作等等

**同步机制设计规则**

- 空闲让进
- 忙则等待
- 有限等待
  - 访问临界资源的进程应保证在有限的时间内进入自己的临界区
- 让权等待
  - 进程不能进入自己的临界区时，应立即释放临界资源

**原子操作**

- 原子操作是指一次不存在任何中断或失败的操作
  - 破除冲突的时间条件
  - 原子性指令的执行是排他的
  - 执行时间窗口与其他访问不重叠

### (1) 操作系统中的原子操作

- OS中定义了专用的原子操作
  - linux下的原子数据类型: atomic_t
- CPU原子指令支持
  - X86: 带lock前端的汇编
  - MIPS: 专用的LL/SL指令
  - ARM: ldrex/strex指令

- 整数型原子指令
- 位级原子操作

## 三、内存屏障

- 指令乱序执行的原因
  - 编译器的指令调度优化
  - 硬件的存储一致性模型

**存储一致性模型**

- Cache Coherency
  - 保证数据单元访问的一致性和原子性
- Memory Consistency
  - 规定处理器访存指令的执行序列
  - 描述处理器全局访存视图

### (1) 屏障原语

- 编译乱序的屏障原语
  - 控制编译乱序
  - 控制编译器的调度优化不得跨越屏障
  - Barrier
- 流水线指令乱序的内存屏障原语
  - 控制流水线执行乱序
  - 保证屏障原语前后指令的执行有序
  - mb,rmb,wmb,smp_mb,smp_rmb,smp_wmb

**Barrier**

- volatile关键字通知编译器不能对本段代码乱序混排
  - 保证了barrier前后的源码执行的有序
- memory关键字通知编译器本处可能会更改所有内存状态， barrier之前的存放于寄存器中的值都已经无效
  - 因此barrier之后的所有变量的值都需要从内存中重新获取，杜绝了乱序执行的可能

**mb屏障原语**

- 保证前后执行的指令严格有序

## 四、锁

- 思路
  - 破除同步冲突的时间重叠条件
  - 一种软件机制，实现复杂，需要硬件指令支持

- 场景
  - 适合于控制执行时间较长的临界区

- 典型锁
  - 自旋锁、读写锁、信号量、RCU

| 原子操作 |    锁    |
| :------: | :------: |
| 功能单一 | 功能全面 |
|  开销小  |  开销大  |

### (1) 使用锁

- 锁是一个内存中的对象，提供
  - Acquire(): 获取锁，进入临界区
  - Release(): 释放锁，退出临界区
- 进程pair calls来获取和释放锁
  - 在acquire/release之间，线程hold锁
  - 直到锁的拥有者释放锁，acquire才可以返回

### (2) 自旋锁

- 自旋锁的设计原理
  - 若锁未被占用，则立刻获得锁，并继续执行
  - 若锁被占用，忙等，等待锁被释放
  - 阻止两个或以上的进程同时进入临界区

- 特点
  - 轻量级、单一拥有者
  - 只能加锁一小段时间
    - 一般不超过两个进程切换的时间开销
  - 可以在中断上下文中使用
- 锁中存在临界区
  - 硬件中断
  - 原子操作指令与互斥锁
  - 基于软件

#### 禁用中断以实现互斥

- 禁用中断以屏蔽外部事务
  - 引入不可中断的代码
  - 使用串行思维
  - 延迟处理外部事件
- 实现方式
  1. 使用锁时禁用中断
  2. 仅在对锁变量进行测试和赋值时通过禁用中断实现互斥
  3. 引入队列 

#### 原子操作指令

**Test-and-Set**

- TAS/TS: 测试和置位指令
  - 从内存单元中读取旧的值
  - 设置该值为真
  - 返回旧的值到内存单元
- 当某个进程获得锁时，old为true(1)，能够保证其他进程自旋，而当该进程释放锁时，正在自旋，且最早进入临界区的进程将获得锁并终止循环

**Exchange**

- 交换寄存器与内存

**Fetch-and-Add/Fetch-and-Op**

- 用于大型共享内存多处理器系统的原子指令

**Load linked和Conditional store(LL-SC)**

1. Loadlinked: 在一条指令中读取一个值
2. 执行操作
3. Store时，检查load linked之后的值是否有修改过，如果有，则从头再来

**无忙等待锁**

- 将等待锁的进程加入等待调度队列而非自旋的方式，实现无忙等待

#### 基于软件方法的忙等待

- Peterson算法
- Dekkers算法
- N线程的软件方法

#### 小结

- 优点
  - 适用于**单处理器或者共享主存的多处理器**中任意数量的进程同步
  - 简单并且容易证明
  - 支持多临界区
- 缺点
  - 忙等待消耗处理器时间
  - 可能导致饥饿
    - 进程离开临界区时有多个等待进程的情况
  - 死锁
    - 拥有临界区的低优先级进程
    - 请求访问临界区的高优先级进程获得处理器并等待临界区

### (3) 读写自旋锁

- 一种效率更高的变种锁，分为读锁、写锁
  - 读锁: 允许多个读进程同时拥有锁
  - 写锁: 只允许1个拥有者，且不允许并发读

#### 设计与实现

- 读写锁
  - 由32位数据表示，含两部分编码
    - 第0-23位：读者数量
    - 第24位：可写标记，为1表示为可写
  - 初始值：0X01000000

**读锁**

- 减1后不小于0，则表示读锁增加成功
- 否则，假1恢复原值，并返回

**写锁**

- 减 0x01000000为零，表示写锁成功
- 否则则表示被读锁/写锁占用，恢复原值后返回

#### seqlock

- 一种“写操作”优先的锁
  - 解决普通read_lock读写优先级相同的问题
- 实现机制
  - **锁带序列号**，每次写时加1
  - 读数据前后判断序列号是否变化，有变化则重试
    - 并发写会使读操作循环重复，直到写锁已释放
- 使用范围
  - 大量读、少量写
  - 优先写操作，避免读操作阻塞写操作
  - 典型场景：jiffies变量的更新
- 使用与开销
  - 读者在读取数据前后，需要两次加锁获取锁
  - 对前后获取锁的seq进行比较，值相等判断加锁成功

#### RCU

>Read-Copy Update

- 读写锁的弊端
  - 读写锁比常规锁更快，但获取读锁仍然开销昂贵
  - 导致忙等、阻塞
  - 持有锁时间长时，所有的读者仍然需要等待
  - 当涉及到对时间敏感的操作时，不好采用
  - 可扩展性差

- 改进思路: lock free
  - 破除并发冲突的资源共享条件
    - 读者和写者分别访问共享数据的不同版本
    - 用空间换时间，借用至数据库设计理念
  - 完全消除锁

**RCU锁设计**

- 适用场景
  - 数据动态分配且被指针访问，典型为链表
  - RCU保护的临界区内不能睡眠
- 设计思想：数据的读版本和写版本分离
  - 写者创建数据的新版本，原子性的交换新旧数据版本
  - 已有的读者仍然使用旧版本，新读者采用新版本
  - 老的版本通过垃圾收集方式(garbage collect)回收
- 优势：没有锁，也没有死锁
  - 读者不会阻塞
  - 写者更新数据时也不会阻塞
  - 开销：需要垃圾回收（GC）

**API**

- 读者相关
  - rcu_read_lock:读者进临界区加锁
  - rcu_read_unlock:读者出临界区解锁
  - rcu_dereference:获取被RCU机制保护的指针
- 写者相关
  - rcu_assign_pointer:原子更新被RCU机制保护的指针
- 回收相关
  - synchronize_rcu:阻塞，直到所有CPU已经退出RCU临界区
  - call_rcu:回收已经被删除的数据

**垃圾回收**

- 访问清空
  - 需要确认对数据的reference都已完成，即“访问清空”
  - synchronize_rcu“等待清空”
  - call_rcu“回调机制”实现数据回收
- 非抢占内核下
  - 实现非常简单，相当多函数为空，开销低
  - 进程切换保证进入了quiescence状态
- 抢占内核下
  - 采用引用计数方式(reference counting)
  - 实现复杂，通过软中断tasklet等机制完成清空与回调

**评价**

- 优势
  - 读者永远不阻塞,写者永远不阻塞
  - CPU核数极多时，仍然具有良好的扩展性
  - 没有死锁
- 弊端
  - 适合类似指针链表场景有限
  - 当存在多个并发写者时仍然需要额外机制进行同步
  - 需要维护多个数据版本
  - 一般用高层次API进行编程
    - 例如 list API、Tree API 
- 在Linux内核中的使用情况
  - 2002年35处使用
  - 2012年超过10000处