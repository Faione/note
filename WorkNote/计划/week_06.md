## 计划池

|          |       |
| :------: | :---: |
| complete |   3   |
|  delay   |  17   |
|  cancel  |   0   |
|  total   |  20   |

ebpf
- [ ] {文档} 了解 ebpf opcode 和 verify 过程
- [ ] {代码} 为 libbpf 社区贡献 rust example 代码
- [ ] {代码} 系统调用采集器

k8s
- [ ] {代码} operator 相关api
- [ ] {文档} operator 教程

rcore
- [x] {代码} 完成基于virtio的block dev，通过相关测例{5.1}
- [ ] {文档} 整理 rust 相关内容(引用与解引用)

工作
- [x] {文档} overlayfs 原理复习
- [ ] {文档} docker原理复习
- [ ] {文档} k8s Reconcile
- [ ] {文档} k8s原理复习

信息高铁
- [ ] {文档} harbor p2p 分发功能调研

华为合作W
- [ ] {文档} 调研典型业务画像过程
- [ ] {文档} 调研典型业务负载分析方式
- [ ] {文档} tailbench docker 脚本
- [ ] {文档} redis， memcache， nginx， mysql， kafka， keydb， elasitc search，clickhouse，spark，hive
- [ ] {代码} 典型应用 syscall 画像
- [ ] {代码} client/server型tailbench
 
其他
- [x] {代码} tokio && async rust
- [ ] {代码} async in libbpf-rs
- [ ] {文档} runC架构
- [ ] {文档} rust youki等调研
- [ ] {文档} OScamp系统功能赛道
- [ ] {文档} laTex语法学习{5.1}
- [ ] {文档} LibOS/Unikernel调研


<table>
<tr>
<th></th>
<th>周一</th>
<th>周二</th>
<th>周三</th>
<th>周四</th>
<th>周五</th>
<th>周六</th>
<th>周天</th>
</tr>

<!-- ---------------- 计划 ---------------- -->
<tr>
<th>计划</th>

<!-- 周一 -->
<th>
1. 完成基于virtio的block dev，通过相关测例 <br>
</th>

<!-- 周二 -->
<th>
1. tokio && async rust <br>
</th>

<!-- 周三 -->
<th>
休息
</th>

<!-- 周四 -->
<th>
1. 调研典型业务画像过程 <br>
2. 调研典型业务负载分析方式 <br>
</th>

<!-- 周五 -->
<th>
</th>

<!-- 周六 -->
<th>
</th>

<!-- 周天 -->
<th>
</th>

</tr>

<!-- ---------------- 完成 ---------------- -->
<tr>
<th>完成</th>

<!-- 周一 -->
<th>
1. 完成基于virtio的block dev，通过相关测例 <br>
</th>

<!-- 周二 -->
<th>
1. tokio && async rust 调研完成 <br>
</th>

<!-- 周三 -->
<th>
休息
</th>

<!-- 周四 -->
<th>
1. pass <br>
2. pass <br>
</th>

<!-- 周五 -->
<th>
</th>

<!-- 周六 -->
<th>
</th>

<!-- 周天 -->
<th>
</th>

</tr>

<!-- ---------------- 刷题 ---------------- -->
<tr>
<th>刷题</th>

<!-- 周一 -->
<th>
</th>

<!-- 周二 -->
<th>
</th>

<!-- 周三 -->
<th>
</th>

<!-- 周四 -->
<th>
</th>

<!-- 周五 -->
<th>
</th>

<!-- 周六 -->
<th>
</th>

<!-- 周天 -->
<th>
</th>

</tr>

</table>


12. dfs 深度优先遍历, 使用 used 数组来取代 visited 数组，即将已遍历过的字符设置为 `#` 等特殊字符，标记其已经被遍历过，同时注意C中需使用 `strlen` 来获取字符串长度
13. dfs 深度优先遍历，构造 visited 数组用来判断某个格子是否已经被访问过
14. 动态规划, 对于长度为i的绳子，考虑仁义剪法，都可将其视为两部分，其中一段不剪开，长度为j, 则另一段长度为 i-j, 如果另一段也不剪，则乘积为 j * (i-j), 而另一段如果要剪，则问题变为了求长度 i-j 绳子的最大乘积，显然可以用一个(n + 1)数组 dp[n + 1] 来保存从长度为 2 到长度为 n 的绳子的最大乘积, 则思路就从长度为2的绳子开始，依次补全dp, 最后返回dp[n]即可
15. 对大数进行判断，更换思路，考虑当  m = n / e 时能够取得极大值，因而如果能够将 n 拆成3和2的组合，并在能取到3的前提下，尽可能地使得3多出现，就能够达到最大值，因而只需要不断让 n 减去3, 同时在过程中，使用 long 存储结果，并在每次计算时取模，解决大数问题
16. n &= (n-1) 消去最右边的1
17. 快速幂的原理在于，如果指数是偶数，则可以将指数减半，底数取平方的形式减少连续乘法的次数，如果是奇数，则可以提取出一个，对余下部分继续使用快速幂，使用快速幂，同时使用 long 替换int 类型的指数，以保证求绝对值时不会发生溢出错误(负数总比正数多一个)