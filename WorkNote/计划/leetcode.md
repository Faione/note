
jz

5. 根据先序，中序重建二叉树，采用分而治之，递归的思想，preorder[0] 为根， inorder中根左边为左子树，右边为右子树，可获得子树长度，再回到preorder中, 由于总是先左子树再右子树，同时又知道子树长度，因此很容易得到preorder中的左/右子树
6. 双栈队列，其中一个用于尾插，另一个用于头出，实际实现中，正常入栈进行尾插，而再头出时，会将尾插栈全部出栈并保存到头出栈中，实现逆序，再进行头出
7. 无意义
8. 进阶斐波那契, 考虑最后一跳要么是1级, 要么是2级, 应此跳上n级台阶所用的次数就存在`d[n] = d[n-1] + d[n-2]`，从而分而治之
9. 可硬解，也可以使用二分查找优化，即旋转的点一定在 arr[left] > arr[right] 的区间中

12. dfs 深度优先遍历, 使用 used 数组来取代 visited 数组，即将已遍历过的字符设置为 `#` 等特殊字符，标记其已经被遍历过，同时注意C中需使用 `strlen` 来获取字符串长度
13. dfs 深度优先遍历，构造 visited 数组用来判断某个格子是否已经被访问过
14. 动态规划, 对于长度为i的绳子，考虑仁义剪法，都可将其视为两部分，其中一段不剪开，长度为j, 则另一段长度为 i-j, 如果另一段也不剪，则乘积为 j * (i-j), 而另一段如果要剪，则问题变为了求长度 i-j 绳子的最大乘积，显然可以用一个(n + 1)数组 dp[n + 1] 来保存从长度为 2 到长度为 n 的绳子的最大乘积, 则思路就从长度为2的绳子开始，依次补全dp, 最后返回dp[n]即可
15. 对大数进行判断，更换思路，考虑当  m = n / e 时能够取得极大值，因而如果能够将 n 拆成3和2的组合，并在能取到3的前提下，尽可能地使得3多出现，就能够达到最大值，因而只需要不断让 n 减去3, 同时在过程中，使用 long 存储结果，并在每次计算时取模，解决大数问题
16. n &= (n-1) 消去最右边的1
17. 快速幂的原理在于，如果指数是偶数，则可以将指数减半，底数取平方的形式减少连续乘法的次数，如果是奇数，则可以提取出一个，对余下部分继续使用快速幂，使用快速幂，同时使用 long 替换int 类型的指数，以保证求绝对值时不会发生溢出错误(负数总比正数多一个)


lec

209: 滑动窗口, 注意并非找到滑动窗口的最优解并跳出, 而是基于滑动窗口来实现 On 的遍历, 在暴力算法中, 可以通过移动右边界, 再遍历左边界的方式来遍历所有可能的子序列, 但考虑到假如一个子序列满足 sum >= target, 那么左边界以左的区间实际并没有考虑的意义, 因为其长度必然大于当前的长度, 故可以在当前的基础上, 向左移动左边界来找到最优解
26: 快慢指针, 可以想象为两个数组,一个是原数组, 用来遍历, 另一个是结果数组, 保存符合要求的数据, 只不过在同一个实际数组上, 有序情况下, 慢指针的移动只需判断最后一个值即可
283: 快慢指针, 遍历完毕之后, 末尾填充0即可
844: 快慢指针, 首先通过快慢指针处理字符串中的 '#', 再进行比较
