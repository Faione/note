## 三、内存虚拟化

- [三、内存虚拟化](#三内存虚拟化)
  - [1 内存虚拟化基本概念](#1-内存虚拟化基本概念)
  - [2 地址映射](#2-地址映射)
    - [2.1 直接模式](#21-直接模式)
      - [(1) 读取](#1-读取)
      - [(2) 写入](#2-写入)
      - [(3) 缺页异常](#3-缺页异常)
    - [2.2 影子页表](#22-影子页表)
      - [(1) 工作原理](#1-工作原理)
      - [(2) 优势](#2-优势)
      - [(3) 创建](#3-创建)
      - [(4) 缺页异常](#4-缺页异常)
      - [(5) 一致性维护](#5-一致性维护)
      - [(6) 存在的问题](#6-存在的问题)
    - [2.3 硬件辅助内存虚拟化](#23-硬件辅助内存虚拟化)
      - [2.3.1 EPT（Extended Page Table）技术](#231-eptextended-page-table技术)
### 1 内存虚拟化基本概念

- 内存虚拟化的目的：
  - 给每个虚拟机提供一个从0地址开始的、连续的“物理”内存空间
  - 隔离虚拟机与VMM、虚拟机之间的内存空间
  - 在虚拟机之间调度、共享复用内存资源
  - 为虚拟机按需动态分配内存资源


### 2 地址映射

- 客户机的VCPU使用客户机虚拟地址（GVA）来访问内存，GVA
不能被宿主机CPU直接用来访问内存
- 把客户机虚拟地址（GVA）映射到宿主机物理地址（HPA），让
宿主机CPU能够正确访问客户机内存中的数据

#### 2.1 直接模式

##### (1) 读取

- Guest OS页表项记录的是客户机虚拟地址到宿主机物理地址（机
器地址）的映射
- Guest OS的页表可以直接供宿主机物理MMU部件使用
- Guest OS的页表结构（页表页、页目录页、描述表页）均被VMM
设置为只读，使得Guest OS不能修改自己的页表，更新页表操作
要通过Hypercall调用VMM来完成
- VMM会对页表更新请求进行验证
  -  虚拟机是否试图映射未分配给它的内存页面
  -  虚拟机是否试图修改页目录结构的只读属性

##### (2) 写入

重写Guest OS下页表相关操作
-  Guest OS的页表访问操作和TLB操作需要重写，使用hypercall陷入到
Hypervisor由其帮助完成相关的特权级操作
-  在Guest OS页表中写入的是机器地址，因此，在填充页表时需要先
将Guest物理地址（GPN）转换成Host机器地址（HPN），同样，在
Guest OS读取页表时需要将Host机器地址翻译成对应的Guest物理地
址来使用

##### (3) 缺页异常

Guest Page Fault的处理
- Guest OS在启动时向VMM注册缺页异常处理函数，装载中断描述
符表
- 发生缺页异常时，CPU自动陷入到Ring 0，VMM捕获该异常并调
用VMM自身的缺页异常处理函数
  - 首先根据CR2寄存器确定导致异常发生的故障地址，保存CR2的值
  - 如果故障地址在VMM的地址空间，说明是VMM自己在运行过程中产
生的Page Fault，则由VMM对其进行处理；
  - 如果故障地址在Guest的地址空间，VMM恢复Guest的异常现场（将
CR2的值存储在Guest的异常栈中），返回Guest OS并调用注册的缺
页异常处理函数进行处理，在处理过程中，页表的更新操作需要通过
hypercall调用VMM来完成

#### 2.2 影子页表

##### (1) 工作原理

- Guest OS维护着自身的页表，完成GVA到GPA的映射，该页表并不被宿
主机MMU所使用
- VMM为每套Guest页表维护一套影子页表，对应于Guest中每个进程的页表，负责将GVA转换成HPA，影子页表对Guest不可见
- Guest OS在进行进程调度切换进程上下文时，会试图将调度进来的进程的页表基地址写入到CPU的CR3寄存器中，由于读写CR3寄存器的指令是特权指令，这一操作会导致陷入到VMM，VMM首先保存Guest进程的页表基地址（GPN），再将该进程对应影子页表的基地址填入到CR3寄存器中，使得CPU（MMU）能够通过影子页表将GVA直接转换成HPA，从而完成内存的访问。 
- 当客户机读CR3寄存器时，仍然会陷入VMM，从而将之前保存的Guest进程页表基地址（GPA）返回给客户机。 
- 影子页表与Guest进程页表间要保持同步，即影子页表中的页表项的状态/权限等要与对应的Guest进程页表项保持一致

##### (2) 优势

- 与直接模式相比的优势：
  - 对虚拟机透明，Guest OS无需修改
  - 隔离性好，Guest不知道分配给自己的宿主机物理内存地址
- 普遍适用于无虚拟化扩展的处理器
  - 每个CPU核只有一个页表基地址寄存器（如X86下的CR3），硬
件上只能完成一维页表的转换（或者GVA->GPA，或者GPA->HPA） 
  - 宿主机TLB中缓存的是GVA到HPA的映射

##### (3) 创建

影子页表的建立
- 当Guest OS启动进入保护模式后，VMM创建与Guest OS的页表相对应的影子页表，但此时影子页表还是空的
- 初始时，由于影子页表是空的，Guest的任何内存访问都会引起缺页异常（Page Fault） 
- 如果Guest OS已经为故障GVFN分配了客户机物理页面，即Guest OS页表中相应的页表项已经建立了映射，说明该缺页异常是由于影子页表中相应的映射尚未建立（即宿主机物理内存页面并未分配）引起的
- VMM截获该异常后，根据故障GVFN在Guest OS页表中查找到与之对应的GPFN，再根据P2M映射表得到相应的HPFN，最后将GVFN到HPFN的映射填入影子页表的页表项中，从而完成缺页异常的处理
- 这一处理过程对Guest OS是透明的

##### (4) 缺页异常

影子页表——Guest缺页异常处理（KVM）
- Guest访问内存时产生缺页异常，该异常被VMM捕获
- VMM读取Guest OS页表项，如果发现Guest OS尚未给故障的GVA分配对应的客户机物理页面，那么VMM会向Guest OS注入一个“Page Fault”，触发Guest OS为该异常页面分配客户机物理页面；
- Guest OS尝试修改页表中对应的页表项填入该客户机物理页面，而这一操作会因权限异常而再次被VMM捕获
- VMM查看宿主机上是否为GPFN分配了HPFN，如果尚未分配，则为其分配宿主机物理页面，之后，将GVFN到HPFN的映射更新到影子页表中对应的页表项中
- VMM处理完成后，控制流返回Guest OS，最后返回应用程序继续执行

##### (5) 一致性维护

影子页表与Guest OS页表的一致性维护（KVM） 
- 影子页表->客户机页表同步：
  - 当Guest OS中页表项的“dirty”位未设置时，KVM将影子页表中对应的页表项标记为只读，当该页被写时，会产生一个访问权限异常，KVM能加以捕获从而将CPU、TLB及Shadow页表项的“dirty”标记同步到Guest OS中对应的页表项上
- 客户机页表->影子页表同步：
  - 在shadow 页表中建立GVA到HPA的映射时，如果该GVA对应的是Guest OS中页表页（存储页表的内
存页面），则KVM将对应的页表项标记为只读的，从而能捕获Guest OS对其自身页表的修改，及时将Guest OS页表的变化同步到Shadow页表上

##### (6) 存在的问题

影子页表存在的问题
- 影子页表相关操作带来明显的开销，影响虚拟化的性能
- 开销主要包括：
  - VMM对Guest页表修改操作的拦截
  - Guest页表与影子页表之间的同步维护
  - 对CR3寄存器访问（读/写）的拦截
  - 影子页表维护过程中的上下文切换操作
  - 上述操作在Guest运行过程中非常频繁
- 为了解决性能问题，现代CPU提供了硬件辅助的内存虚拟化技术
  - INTEL：Extended Page Table, EPT
  - AMD：Nested Paging

#### 2.3 硬件辅助内存虚拟化

##### 2.3.1 EPT（Extended Page Table）技术

- Guest OS维护自身的页表，完成GVA到GPA的映射
- 每个Guest对应一套EPT，EPT负责完成GPA到HPA的映射，EPT由VMM维护，对虚拟机透明