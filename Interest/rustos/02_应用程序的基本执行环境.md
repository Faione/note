# 应用程序的基本执行环境

## 一、应用程序的执行环境

- 白色: 各级执行环境
- 黑色: 相邻两层执行环境之间的接口

![应用程序的执行环境](./img/2022-07-26-21-07-35.png)

### 平台与目标三元组

> 裸机平台: 没有任何程序的标准库, 同时也不存在任何受OS支持的系统调用
> 交叉编译: 编译器运行的平台（x86_64）与可执行文件运行的目标平台不同

- 编译器在编译、链接得到可执行文件时需要直到，程序要在那个**平台**上运行，目标三元组描述了目标平台的 **CPU 指令集**、**操作系统类型**和**标准运行时库**
- `host: x86_64-unknown-linux-gnu`
  - `x86_64`: CPU架构, `unknown`: CPU厂商
  - `linux`: 操作系统
  - `gnu libc`: 运行时库
- rust核心库core不需要任何操作系统的支持, 以裸机平台为目标编译程序,需要将标准库std的引用替换为核心库core

## 二、移除标准库依赖

### 编译器准备

- 为 rustc 添加一个 target: `riscv64gc-unknown-none-elf`

```shell
$ rustup target add riscv64gc-unknown-none-elf
```

- 设置 cargo 的默认目标平台为 `riscv64gc-unknown-none-elf`

### 移除`println!`宏

> Attribute: rust

- 在代码开头增加`#![no_std]`属性, 告知编译器不适用rust标准库而适用核心库
- 在代码开头增加`#![no_main]`属性, 告知编译器该程序没有main入口
- 手动实现`panic_handler`, 去除对std库的依赖

```rust
// os/src/lang_items.rs
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

### 查看编译完成的代码

- 安装 cargo-binutils
  - [cargo-binutils crate](https://docs.rs/crate/cargo-binutils/0.3.6)

```shell
# version 3.6
$ cargo install cargo-binutils

$ rustup component add llvm-tools-preview
```

- 查看文件格式

```shell
$ file target/riscv64gc-unknown-none-elf/debug/os
```

- 查看文件头

```shell
$ rust-readobj -h target/riscv64gc-unknown-none-elf/debug/os
```

- 反汇编得到汇编程序

```shell
$ rust-objdump -S target/riscv64gc-unknown-none-elf/debug/os
```

- 结论
  - 通过 file 工具对二进制程序 os 的分析可以看到，它好像是一个合法的 RV64 执行程序
  - 但 rust-readobj 工具告诉我们它的入口地址 Entry 是 0
  - 再通过 rust-objdump 工具把它反汇编，没有生成任何汇编代码
  - 可见，这个二进制程序虽然合法，但它是一个空程序，原因是缺少了编译器规定的入口函数_start

## 三、构建用户执行环境

### 用户态最小化执行环境

- 增加`#[no_mangle]`属性，告知编译器不要更改函数的label
- 为rust编译器提供入口函数`_start()`

```rust
#[no_mangle]
extern "C" fn _start() {
    loop{};
}
```
> QEMU运行模式
> User mode: 即用户态模拟，如 qemu-riscv64 程序， 能够模拟不同处理器的用户态指令的执行，并可以直接解析ELF可执行文件， 加载运行那些为不同处理器编译的用户级Linux应用程序
> System mode: 系统态模式，如 qemu-system-riscv64 程序， 能够模拟一个完整的基于不同CPU的硬件系统，包括处理器、内存及其他外部设备，支持运行完整的操作系统


- 注释`loop{}`, 在qemu中运行程序会导致崩溃
  - 执行环境缺乏退出机制，需要操作系统提供的`exit`系统调用来退出程序