## 物理页帧管理

### 物理页的分配与回收

按照内存布局, 总内存大小为 8MB, 可用的物理内存范围为 `(ekernel, 0x80800000]` ，而分配物理页帧时，上界向上取整，避免与内核代码重叠，下界向下取整，以获得最多的可用物理帧(此时最后一页可能不满)

对于物理页帧管理器而言，需要满足满足以下功能 `trait`

```rust
trait FrameAllocator {
    fn new() -> Self;
    fn alloc(&mut self) -> Option<PhysPageNum>;
    fn dealloc(&mut self, ppn: PhysPageNum);
}
```

From<T> trait, 假设存在类型 A 与类型 B, 若为类型 A 实现 From<B> trait, 则可通过 `let a: A = B.into()` 或 `let a: A = A::from(B)` , 将 B 类型的变量转化或构造出 A 类型，与此同时，若同时为 A 与 B 实现 `From<T>`, 则能够完成 A 与 B 之间的相互转化
 
虚拟地址 -> usize
- 如果虚拟地址首位为 1，转化为 usize时，高位全部置 1
- 如果虚拟地址首位为 0，转化为 usize时，高位全部置 0
- 这是因为当使用64位地址时，虚拟地址只会使用高 256 GB 与 低 256GB

### 简单栈式物理页帧管理策略

```rust
pub struct StackFrameAllocator {
    current: usize,  //空闲内存的起始物理页号
    end: usize,      //空闲内存的结束物理页号
    recycled: Vec<usize>,
}
```

物理页号区间 [ `current`, `end` ) 此前从未分配出去过，vec recyled 以先入后出的方式保存被回收的物理页号(vec使用的内存通过自定义的堆内存分配器分配(3mb堆空间中))

**分配逻辑**

- 分配 alloc 时,首先检查栈 recycled 内有没有之前回收的物理页号,有则直接弹出栈顶并返回,否则从之前从未分配过的物理页号区间 [ current , end ) 上进行分配我们分配它的左端点 current ，同时将管理器内部维护的 current 加 1 代表 current 已被分配了,在即将返回的时候，我们使用 into 方法将 usize 转换成了物理页号 PhysPageNum 
  - 注意极端情况下可能出现内存耗尽分配失败的情况：即 recycled 为空且 current == end 。为了涵盖这种情况， alloc 的返回值被 Option 包裹，我们返回 None 即可

- 回收 dealloc 时，需要检查回收页面的合法性，然后将其压入 recycled 栈中
- 回收页面合法有两个条件：
  - 该页面之前一定被分配出去过，因此它的物理页号一定 < current
  - 该页面没有正处在回收状态，即它的物理页号不能在栈 recycled 中找到,通过 recycled.iter() 获取栈上内容的迭代器，然后通过迭代器的 find 方法试图寻找一个与输入物理页号相同的元素。其返回值是一个 Option ，如果找到了就会是一个 Option::Some ，这种情况说明我们内核其他部分实现有误，直接报错退出

[RAII思想](https://rustmagazine.github.io/rust_magazine_2021/chapter_4/rust-to-system-essence-raii.html)

### 多级页表管理

### 页表基本数据结构与访问接口

### 内核中访问物理页帧

通过物理页号，构造可变引用来直接访问一个物理页号 PhysPageNum 对应的物理页帧，不同的引用类型对应于物理页帧上的一种不同的内存布局，如 get_pte_array 返回的是一个页表项定长数组的可变引用，代表多级页表中的一个节点；而 get_bytes_array 返回的是一个字节数组的可变引用，可以以字节为粒度对物理页帧上的数据进行访问，前面进行数据清零就用到了这个方法； get_mut 是个泛型函数，可以获取一个恰好放在一个物理页帧开头的类型为 T 的数据的可变引用

### 建立和拆除虚实地址映射关系

