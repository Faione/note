## 物理页帧管理

### 物理页的分配与回收

按照内存布局, 总内存大小为 8MB, 可用的物理内存范围为 `(ekernel, 0x80800000]` ，而分配物理页帧时，上界向上取整，避免与内核代码重叠，下界向下取整，以获得最多的可用物理帧(此时最后一页可能不满)

对于物理页帧管理器而言，需要满足满足以下功能 `trait`

```rust
trait FrameAllocator {
    fn new() -> Self;
    fn alloc(&mut self) -> Option<PhysPageNum>;
    fn dealloc(&mut self, ppn: PhysPageNum);
}
```

From<T> trait, 假设存在类型 A 与类型 B, 若为类型 A 实现 From<B> trait, 则可通过 `let a: A = B.into()` 或 `let a: A = A::from(B)` , 将 B 类型的变量转化或构造出 A 类型，与此同时，若同时为 A 与 B 实现 `From<T>`, 则能够完成 A 与 B 之间的相互转化
 
虚拟地址 -> usize
- 如果虚拟地址首位为 1，转化为 usize时，高位全部置 1
- 如果虚拟地址首位为 0，转化为 usize时，高位全部置 0
- 这是因为当使用64位地址时，虚拟地址只会使用高 256 GB 与 低 256GB

### 简单栈式物理页帧管理策略

```rust
pub struct StackFrameAllocator {
    current: usize,  //空闲内存的起始物理页号
    end: usize,      //空闲内存的结束物理页号
    recycled: Vec<usize>,
}
```

物理页号区间 [ `current`, `end` ) 此前从未分配出去过，vec recyled 以先入后出的方式保存被回收的物理页号(vec使用的内存通过自定义的堆内存分配器分配(3mb堆空间中))

**分配逻辑**

分配 alloc 时,首先检查栈 recycled 内有没有之前回收的物理页号,有则直接弹出栈顶并返回,否则从之前从未分配过的物理页号区间 [ current , end ) 上进行分配我们分配它的左端点 current ，同时将管理器内部维护的 current 加 1 代表 current 已被分配了,在即将返回的时候，我们使用 into 方法将 usize 转换成了物理页号 PhysPageNum 
  - 注意: 极端情况下可能出现内存耗尽分配失败的情况：即 recycled 为空且 current == end 。为了涵盖这种情况， alloc 的返回值被 Option 包裹，我们返回 None 即可

回收 dealloc 时，需要检查回收页面的合法性，然后将其压入 recycled 栈中, 回收页面合法有两个条件：
  - 该页面之前一定被分配出去过，因此它的物理页号一定 < current
  - 该页面没有正处在回收状态，即它的物理页号不能在栈 recycled 中找到
通过 recycled.iter() 获取栈上内容的迭代器，然后通过迭代器的 find 方法试图寻找一个与输入物理页号相同的元素, 其返回值是一个 Option ，如果找到了就会是一个 Option::Some ，这种情况说明内核其他部分实现有误，直接报错退出

[RAII思想](https://rustmagazine.github.io/rust_magazine_2021/chapter_4/rust-to-system-essence-raii.html)

### 多级页表管理

SV39 多级页表是以节点为单位进行管理， 每个节点恰好存储在一个物理页帧中，它的位置可以用一个物理页号来表示

多级页表使用数据结构PageTable来保存，多级页表(PageTable)由多个节点组成，每个节点都被保存在一个物理页帧中，一个节点所在的物理页帧的物理页号就是指向该节点的指针, 而初始化 PageTable 时所分配的物理页帧即多级页表中的三级页表(根节点)，其 PhysPageNum 保存在 PageTable 的 root_ppn 变量中，用来区分不同应用的多级页表，而多级页表中的所有节点，都保存在 frames 中, FrameTracker 保存了这些节点的 PhysPageNum，而当PageTable被释放时，该应用所有的页表都会被回收

```rust
pub struct PageTable {
    root_ppn: PhysPageNum,
    frames: Vec<FrameTracker>,
}

impl PageTable {
    pub fn new() -> Self {
        let frame = frame_alloc().unwrap();
        PageTable {
            root_ppn: frame.ppn,
            frames: vec![frame],
        }
    }
}
```

多级页表在创建之后是动态变化的，因此操作系统需要动态维护一个虚拟页号到页表项的映射，支持插入与删除键值对

```rust
impl PageTable {
    // 通过 map 方法来在多级页表中插入一个键值对，注意这里将物理页号 ppn 和页表项标志位 flags 作为不同的参数传入
    pub fn map(&mut self, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags);
    // 通过 unmap 方法来删除一个键值对，在调用时仅需给出作为索引的虚拟页号即可
    pub fn unmap(&mut self, vpn: VirtPageNum);
}
```

尚未启用分页模式之前，内核和应用的代码都可以通过物理地址直接访问内存。打开分页模式之后，运行在 S 特权级的内核与运行在 U 特权级的应用在访存上都会受到影响，它们的访存地址会被视为一个当前地址空间（ satp CSR 给出当前多级页表根节点的物理页号）中的一个虚拟地址，需要 MMU 查相应的多级页表完成地址转换变为物理地址，即地址空间中虚拟地址指向的数据真正被内核放在的物理内存中的位置，然后才能访问相应的数据

此时，如果想要访问一个特定的物理地址 pa 所指向的内存上的数据，就需要构造对应的一个虚拟地址 va ，使得当前地址空间的页表存在映射 va -> pa  ，且页表项中的保护位允许这种访问方式。于是，在代码中我们只需访问地址 va ，它便会被 MMU 通过地址转换变成 pa ，这样就做到了在启用分页模式的情况下也能正常访问内存

如果内核想要直接访问任意的一个物理页帧，需要提前扩充多级页表维护的映射，让每个物理页帧的物理页号 ppn ，均存在一个对应的虚拟页号 vpn ，这需要建立一种映射关系。这里我们采用一种最简单的 恒等映射 (Identical Mapping) ，即对于物理内存上的每个物理页帧，我们都在多级页表中用一个与其物理页号相等的虚拟页号来映射


### 内核中访问物理页帧

通过物理页号，构造可变引用来直接访问一个物理页号 PhysPageNum 对应的物理页帧，不同的引用类型对应于物理页帧上的一种不同的内存布局，如 get_pte_array 返回的是一个页表项定长数组的可变引用，代表多级页表中的一个节点；而 get_bytes_array 返回的是一个字节数组的可变引用，可以以字节为粒度对物理页帧上的数据进行访问，前面进行数据清零就用到了这个方法； get_mut 是个泛型函数，可以获取一个恰好放在一个物理页帧开头的类型为 T 的数据的可变引用

### 建立和拆除虚实地址映射关系

