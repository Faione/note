## 分时多任务系统与抢占式调度

**协作式调度**

协作式调度 (Cooperative Scheduling) ，因为它的特征是：只要一个应用不主动 yield 交出 CPU 使用权，它就会一直执行下去。与之相对， 抢占式调度 (Preemptive Scheduling) 则是应用 随时 都有被内核切换出去的可能

### RISC-V架构中的中断

时间片轮转调度的核心机制就在于计时。操作系统的计时功能是依靠硬件提供的时钟中断来实现的
#### 中断

在 RISC-V 中， 中断 (Interrupt) 与异常(包括程序错误导致或执行 Trap 类指令如用于系统调用的 ecall ) 一样都是一种 **Trap** ，但被触发的原因有所不同: 
- 对于某个处理器核(Hart)而言，异常与当前 CPU 指令的执行是 **同步 (Synchronous)** 的，异常被触发的原因一定能够追溯到某条指令的执行
- 而中断则 **异步 (Asynchronous)** 于当前正在进行的指令，即中断来自于哪个外设以及中断如何触发完全与处理器正在执行的当前指令无关

从控制流来看，异常是在当前执行的指令后分离，在异常控制流执行完毕后，返回时继续执行下一条指令, 其流程类似于调用一个函数，而中断则是在指令执行时分离(中断周期), 中断执行完毕后，则接着当前执行继续执行

**从底层硬件的角度区分同步和异步**

从底层硬件的角度出发，以一个处理器的五级流水线设计而言，里面含有 `取指、译码、算术、访存、寄存器` 等单元，都属于执行指令所需的硬件资源
- 对于异常，假如某条指令的执行出现了问题，一定能被其中某个单元看到并反馈给流水线控制单元，从而它会在执行预定的下一条指令之前先进入异常处理流程，也即异常在这些单元内部即可被发现并解决
- 而对于中断，可以认为发起中断的是一套 **与处理器执行指令无关** 的电路(从时钟中断来看就是简单的计数和比较器)，这套电路仅通过一根导线接入处理器。当外设想要触发中断的时候则输入一个高电平或正边沿，处理器会在每执行完一条指令之后检查一下这根线，看情况决定是继续执行接下来的指令还是进入中断处理流程。也就是说，大多数情况下，指令执行的相关硬件单元和可能发起中断的电路是完全独立 **并行 (Parallel)** 运行的，它们中间只有一根导线相连

**中断表**

| Interrupt | Exception Code |          Description          |
| :-------: | :------------: | :---------------------------: |
|     1     |       1        | Supervisor software interrupt |
|     1     |       3        |  Machine software interrupt   |
|     1     |       5        |  Supervisor timer interrupt   |
|     1     |       7        |    Machine timer interrupt    |
|     1     |       9        | Supervisor external interrupt |
|     1     |       11       |  Machine external interrupt   |


RISC-V 的中断可以分成三类
- 软件中断 (Software Interrupt)：由软件控制发出的中断
- 时钟中断 (Timer Interrupt)：由时钟电路发出的中断
- 外部中断 (External Interrupt)：由外设发出的中断

相比于异常，中断和特权级之间的联系更为紧密，三种中断中，每一个都有 M/S 两个版本，中断的特权级可以决定该中断是否会被屏蔽，以及需要Trap到CPU的哪个特权级继续处理。在判断中断是否会被屏蔽的时候，有以下规则：
- 如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽，不会被处理；
- 如果中断的特权级高于与 CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽

以内核所在的S特权级为例，中断屏蔽相应的CSR有 `sstatus` 和 `sie`:
- `sstatus` 的 `sie` 为 S 特权级的中断使能(不要跟寄存器 sie 混淆)，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽
- 即使 `sstatus.sie` 置 1 ，还需要看 `sie` 这个 CSR，它的三个字段 `ssie/stie/seie` 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能
  - 比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要 sstatus.sie 和 sie.stie 均为 1 该中断才不会被屏蔽；如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽

如果中断没有被屏蔽，那么接下来就需要软件进行处理，而具体到哪个特权级进行处理与一些中断代理 CSR 的设置有关。默认情况下，所有的中断都需要到 M 特权级处理。而通过软件设置这些中断代理 CSR 之后，就可以到低特权级处理，但是 Trap 到的特权级不能低于中断的特权级。事实上所有的中断/异常默认也都是到 M 特权级处理的
- U 特权级的应用程序发出系统调用或产生错误异常都会跳转到 S 特权级的操作系统内核来处理；
- S 特权级的时钟/软件/外部中断产生后，都会跳转到 S 特权级的操作系统内核来处理。

同时，默认情况下，当中断产生并进入某个特权级之后，在中断处理的过程中同特权级的中断都会被屏蔽。中断产生后，硬件会完成如下事务:
- 当中断发生时，`sstatus.sie` 字段会被保存在 `sstatus.spie` 字段中，同时把 `sstatus.sie` 字段置零，这样软件在进行后续的中断处理过程中，所有 S 特权级的中断都会被屏蔽；
- 当软件执行中断处理完毕后，会执行 `sret` 指令返回到被中断打断的地方继续执行，硬件会把 `sstatus.sie` 字段恢复为 `sstatus.spie` 字段内的值

因而只要不手动设置 `sstatus` CSR, 在只考虑S特权级中断的情况下，不会有 **中断嵌套(Nested Interrupt)** 的情况

### 时钟中断与计时器

RISC-V 中与时间相关的寄存器有两个，都是M特权级的CSR，处于S级的内核能够通过运行在M特权级的SEE(RustSBI)预留的接口来间接实现对计时器的控制
`mtime`寄存器: 64位的CSR寄存器，用来统计处理器自上电以来经过了多少个内置时钟的时钟周期(而非时间)，无需担心溢出问题，在内核运行全程可以认为是一直递增的
`mtimecmp`寄存器: 一旦计数器`mtime`的值超过了mtimecmp，就会触发一次时钟中断


应用初始化的 Trap 上下文中的 sstatus 中的 SPIE 值并未初始化为 1 。这将意味着 CPU 在用户态执行应用的时候 sstatus 的 SIE 为 0 ，根据定义来说，此时的 CPU 会屏蔽 S 态所有中断，自然也包括 S 特权级时钟中断。但是可以观察到我们的应用在用尽一个时间片之后能够正常被打断。这是因为当 CPU 在 U 态接收到一个 S 态时钟中断时会被抢占，这时无论 SIE 位是否被设置都会进入 Trap 处理流程, 即如果用户流在U模式下时，sstatus.SIE 位不会影响中断响应判断，此时任何S特权级的中断都会被响应

### 深入Print! 宏

print!中含有fmt时，输出断续内容的原因
- print!宏中，使用了format_args!，将宏的输入参数转化为了Arguments，其中包含args，为<value, formatter>构成的数组
- 当输入参数中没有使用任何fmt时(没有`{}`), 参数只有一个,即args长度为1，调用`write_str`一次性将所有文本打印出
- 而当输入参数中含有多个fmt时，则会调用多次`write_str`(基于fmt的数量), 而每次调用的间隙，存在被打断的可能，从而导致断续的内容打印, 尽管这些内容在同一个print!中
- println!中没有fmt时，默认调用一次write，而当其中存在fmt时，则需注意其末尾隐含添加的"\n", 添加多少个"{}"， 就类似于将文本切分为多少块，然后根据块数调用write


```rust
/rust/library/core/src/fmt/mod.rs
pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {
    let mut formatter = Formatter::new(output);
    let mut idx = 0;

    match args.fmt {
        None => {
            // We can use default formatting parameters for all arguments.
            for (i, arg) in args.args.iter().enumerate() {
                // SAFETY: args.args and args.pieces come from the same Arguments,
                // which guarantees the indexes are always within bounds.
                let piece = unsafe { args.pieces.get_unchecked(i) };
                if !piece.is_empty() {
                    formatter.buf.write_str(*piece)?;
                }
                (arg.formatter)(arg.value, &mut formatter)?;
                idx += 1;
            }
        }
        Some(fmt) => {
            // Every spec has a corresponding argument that is preceded by
            // a string piece.
            for (i, arg) in fmt.iter().enumerate() {
                // SAFETY: fmt and args.pieces come from the same Arguments,
                // which guarantees the indexes are always within bounds.
                let piece = unsafe { args.pieces.get_unchecked(i) };
                if !piece.is_empty() {
                    formatter.buf.write_str(*piece)?;
                }
                // SAFETY: arg and args.args come from the same Arguments,
                // which guarantees the indexes are always within bounds.
                unsafe { run(&mut formatter, arg, args.args) }?;
                idx += 1;
            }
        }
    }

    // There can be only one trailing string piece left.
    if let Some(piece) = args.pieces.get(idx) {
        formatter.buf.write_str(*piece)?;
    }

    Ok(())
}
```