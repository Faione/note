## 进程

因此，进程就是操作系统选取某个可执行文件并对其进行一次动态执行的过程。相比可执行文件，它的动态性主要体现在：
1. 它是一个过程，从时间上来看有开始也有结束；
2. 在该过程中对于可执行文件中给出的需求要相应对 **硬件/虚拟资源** 进行 **动态绑定和解绑** 

简单进程模型
- 三个运行状态：就绪态、运行态和等待态
- 基于独立页表的地址空间
- 可被操作系统调度来分时占用 CPU 执行
- 可以动态创建和退出
- 可通过系统调用获得操作系统的服务

## 相关系统调用

**fork 系统调用**

```rust
/// 功能：当前进程 fork 出来一个子进程。
/// 返回值：对于子进程返回 0，对于当前进程则返回子进程的 PID 。
/// syscall ID：220
pub fn sys_fork() -> isize;
```

**waitpid 系统调用**

```rust
/// 功能：当前进程等待一个子进程变为僵尸进程，回收其全部资源并收集其返回值。
/// 参数：pid 表示要等待的子进程的进程 ID，如果为 -1 的话表示等待任意一个子进程；
/// exit_code 表示保存子进程返回值的地址，如果这个地址为 0 的话表示不必保存。
/// 返回值：如果要等待的子进程不存在则返回 -1；否则如果要等待的子进程均未结束则返回 -2；
/// 否则返回结束的子进程的进程 ID。
/// syscall ID：260
pub fn sys_waitpid(pid: isize, exit_code: *mut i32) -> isize;
```

**exec 系统调用**

```rust
/// 功能：将当前进程的地址空间清空并加载一个特定的可执行文件，返回用户态后开始它的执行。
/// 参数：path 给出了要加载的可执行文件的名字；
/// 返回值：如果出错的话（如找不到名字相符的可执行文件）则返回 -1，否则不应该返回。
/// syscall ID：221
pub fn sys_exec(path: &str) -> isize;
```

## 应用程序

**read 系统调用**

```rust
/// 功能：从文件中读取一段内容到缓冲区。
/// 参数：fd 是待读取文件的文件描述符，切片 buffer 则给出缓冲区。
/// 返回值：如果出现了错误则返回 -1，否则返回实际读到的字节数。
/// syscall ID：63
pub fn sys_read(fd: usize, buffer: &mut [u8]) -> isize;
```

```rust
const LF:u8 = 0x0au8;
const CR:u8 = 0x0du8;
const DL:u8 = 0x7fu8;
const BS:u8 = 0x08u8;
```

[ASCII表](https://www.runoob.com/w3cnote/ascii.html)

CR: 0x0d, Carriage Return, 回车, 将光标移动当当前行的开头
LF: 0x0a, Line Feed, 换行, 将光标"垂直"移动到下一行
DL: 0x7f, Del, 删除, 删除光标后的一个字符
BS: 0x08, Back Space, 删除光标后的一个字符
