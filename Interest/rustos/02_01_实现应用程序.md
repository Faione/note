# 实现应用程序 

批处理系统中，应用程序实现的要点是
- 应用程序的内存布局
- 应用程序发出的系统调用


## 应用程序内存布局

- 所有用户应用都需要引入用户库`user_lib`，然后再定义自己的main函数，作为用户应用的主逻辑入口

### 用户库

> lib中声明了#![feature(linkage)]属性，并提供了一个`main`函数，使用`linkage = "weak"`属性标记，使得当编译器没有找到`main`函数标签时，就会使用此`main`函数进行替代

- lib中定义了用户库入口点`_start`, 其最终代码将被放入`.test.entry`代码段中，其功能为
  - 清空`.bss`段
  - 调用`main`函数，并接收其返回值(i32)
  - 调用`exit`接口退出用户程序，并将上一步获得的返回值告知批处理系统

### 内存布局

linker.ld链接脚本中声明
- 将程序的起始物理地址调整为 0x80400000 ，用户应用程序都会被加载到这个物理地址上运行
- 将`_start`所在的`.text.entry`放在整个程序的开头, 即当批处理系统加载并跳转到地址`0x80400000`之后, 便进入了用户库的入口点，并会在初始化之后跳转到应用程序主逻辑
- 提供了最终生成可执行文件的`.bss`段的起始和终止地址，方便`clear_bss`函数使用

## 应用程序的系统调用

应用程序通过ABI库进行系统调用, 而在ABI库的核心是通过指令`ecall`以实现特权级的切换，并通过相应内核代码执行操作
程序二进制接口以符合RISC-V规范的内联汇编的方式进行实现
- ecall 指令与函数一样，同样有着输入和输出寄存寄存器，a0~a2 和a7作为输入寄存器分别表示**系统调用参数**和**系统调用ID**，而当系统调用返回后，a0 作为输出寄存器保存系统调用的返回值
  - x10~x17 对应于 a0~a7, 内联汇编中，使用`inlateout`标识同时作为输入和输出的寄存器`x10` 

```rust
fn syscall(id: usize, args: [usize; 3]) -> isize {
    let mut ret: isize;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") args[0] => ret,
            in("x11") args[1],
            in("x12") args[2],
            in("x17") id
        );
    }
    ret
}
```

批处理系统为应用程序提供`write`与`exit`两个系统调用，前者还提供了宏，以便用户程序进行信息的打印，后者则默认添加在`_start`中，当用户程序主逻辑结束时，就会自动执行，以告知批处理系统当前程序执行完毕



