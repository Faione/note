## 函数调用栈

- 函数的调用的返回跳转是跳转到一个`运行时确定`的地`址

**risc-v中的函数调用**

- 指令`jal`, 将当前指令的下一条指令保存在寄存器`rd`中, 同时修改当前pc为`pc+imm`
  - riscv中，rd通常为x1寄存器
- 指令`ret`用于函数返回，通常被汇编器汇编为`jalr x0, 0(x1)`
  - 由于x0为恒零寄存器，因此指令的作用为修改当前pc为x1中的值，即之前保存的下一条指令地址

**函数上下文**

- 在控制流转移前后，需要保持不变的寄存器集合
- 通常分为两类
  - 被调用者保存(Callee-Saved)寄存器: 
    - 被调用的函数可能会覆盖这些寄存器，需要被调用的函数来保存的寄存器，即由被调用的函数来保证在调用前后，这些寄存器保持不变
  - 调用者保存(Caller-Saved)寄存器:
    - 被调用的函数可能会覆盖这些寄存器，需要发起调用的函数来保存的寄存器，即由发起调用的函数来保证在调用前后，这些寄存器保持不变

 - 函数的**开场**(Prologue)和**结尾**(Epilogue)
   - 调用函数
     - 首先保存不希望在函数调用过程中发生变化的**调用者保存寄存器** ，然后通过 jal/jalr 指令调用子函数，返回之后恢复这些寄存器
   - 被调用函数
     - 在被调用函数的起始，先保存函数执行过程中被用到的**被调用者保存寄存器** ，然后执行函数，最后在函数退出之前恢复这些寄存器

### 调用规范

- **调用规范**(Calling Convention)约定在某个指令集架构上，某种编程语言的函数调用如何实现
  - 函数的输入参数和返回值如何传递
  - 函数调用上下文中调用者/被调用者保存寄存器的划分
  - 其他的在函数调用流程中对于寄存器的使用方法
- 调用规范针对一种特定的函数语言来说的，因此当一种语言想要调用使用另一门语言编写的函数接口时，编译器就必须同时清楚两种语言的调用规范，并对寄存器做出调整

- 函数调用与栈帧

![](./img/2022-08-27-17-12-11.png)

**函数栈帧的组成**

- 栈帧的开头和结尾分别在 sp(x2) 和 fp(s0) 所指向的地址
- 按照地址从高到低分别有以下内容，它们都是通过 sp 加上一个偏移量来访问的
  1. ra寄存器保存其返回之后的跳转地址，是一个调用者保存寄存器
  2. 父亲栈帧的结束地址fp ，是一个被调用者保存寄存器；
  3. 其他被调用者保存寄存器 s1 ~ s11
  4. 函数所使用到的局部变量

![](./img/2022-08-27-17-12-17.png)

### 分配并使用启动栈

- 在`.bss.stack`段中声明启动栈，其中`boot_stack`标识栈底，`boot_stack_top`标识栈顶

```asm
    .section .text.entry
    .globl _start
_start:
    la sp, boot_stack_top
    call rust_main

    .section .bss.stack
    .globl boot_stack
boot_stack:
    .space 4096 * 16
    .globl boot_stack_top
boot_stack_top
```

- 使用rust代码进程 .bss 段的清零
  - extern "C" 可以引用一个外部的C函数接口，此处并没有进行函数调用，只是引用位置标志，从而获得.bss段两端的地址，并对其内容进行置空

```rust
fn clear_bss() {
    extern "C" {
        fn sbss();
        fn ebss();
    }
    (sbss as usize..ebss as usize).for_each(|a| {
        unsafe { (a as *mut u8).write_volatile(0) }
    });
}
```