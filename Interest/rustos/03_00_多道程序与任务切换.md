# 多道程序与任务切换

## 任务切换

Trap控制流切换流程: 

- 阶段[1]: 在Trap控制流A调用`__switch`之前，A的内核栈上只有Trap上下文和Trap处理函数的调用栈信息，而B是之前被切换出去的
- 阶段[2]: A在A任务上下文空间在里面保存CPU当前的寄存器快照
- 阶段[3]: *读取`next_task_cx_ptr`指向的B任务上下文，根据B任务上下文保存的内容来恢复`ra`寄存器、`s0~s11`寄存器以及`sp`寄存器。只有这一步做完后，`__switch`才能做到一个函数跨两条控制流执行，即通过换栈也就实现了控制流的切换 
- 阶段[4]: 上一步寄存器恢复完成后，可以看到通过恢复`sp`寄存器换到了任务B的内核栈上，进而实现了控制流的切换。这就是为什么`__switch`能做到一个函数跨两条控制流执行。此后，当CPU执行`ret`汇编伪指令完成`__switch`函数返回后，任务B可以从调用`__switch`的位置继续向下执行

通过extern声明函数，再进行调用，这样，rust编译时对于switch的处理就与其他函数相同(栈的设置，寄存器保存，返回地址的设置)，不必再手动添加代码

## 任务

为进一步增强操作系统管理能力和对处理器系统的高效利用

- 任务运行状态：任务从开始到结束执行过程中所处的不同运行状态：未初始化、准备执行、正在执行、已退出
- 任务控制块：管理程序的执行过程的任务上下文，控制程序的执行与暂停
- 任务相关系统调用：应用程序和操作系统直接的接口，用于程序主动暂停`sys_yield`和主动退出`sys_exit`

**系统调用yield**


**任务控制块与任务运行状态**

**任务管理器**