## 实现批处理操作系统

操作系统与应用程序放置到同一个可执行文件，应用加载机制: 应用放置采用"静态绑定", 而操作系统加载应用则采"动态加载"的方式
- 静态绑定: 通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码“绑定”在一起
- 动态加载: 基于静态编码留下的“绑定”信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行

### 链接应用到内核

要将应用程序的二进制镜像文件作为内核的数据段链接到内核中, 内核需要知道内涵的应用程序的数量和它们的位置，这样才能在运行时对它们进行管理并能够加载到内存

链接应用之前，需要通过指令`fence.i`清空icache中的内容，从而保证CPU访问内存数据和代码的正确性


## 实现特权级切换

S特权级中与Trap相关的**控制状态寄存器**(CSR, Control and Status Register)

| CSR名称 |                        该CSR与Trap相关的功能                         |
| :-----: | :------------------------------------------------------------------: |
| sstatus |      `SPP`等字段给出Trap发生之前CPU处在哪个特权级（S/U）等信息       |
|  sepc   | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
| scause  |                           描述 Trap 的原因                           |
|  stval  |                          给出 Trap 附加信息                          |
|  stvec  |                     控制 Trap 处理代码的入口地址                     |

当执行一条 Trap 类指令(如 ecall 时)，CPU 发现触发了一个异常并需要进行特殊处理，这涉及到 执行环境切换 。具体而言，用户态执行环境中的应用程序通过 ecall 指令向内核态执行环境中的操作系统请求某项服务功能，那么处理器和操作系统会完成到内核态执行环境的切换，并在操作系统完成服务后，再次切换回用户态执行环境，然后应用程序会紧接着 ecall 指令的后一条指令位置处继续执行

### 硬件功能

当CPU执行完一条指令(如ecall)并准备从U特权级陷入(Trap)到S特权级时, 硬件自动完成如下事情
- `sstatus`的`SPP`字段会被修改为CPU当前的特权级(U/S)
- `sepc`会被修改为Trap处理完成后默认会执行的下一条指令的地址
- `scause/stval`分别会被修改成这次Trap的原因以及相关的附加信息
- CPU 会跳转到`stvec`所设置的Trap处理入口地址，并将当前特权级设置为S，然后从Trap处理入口地址处开始执行

而当CPU完成Trap处理准备返回的时候，需要通过一条S特权级的特权指令`sret`来完成，这一条指令具体完成以下功能
- CPU会将当前的特权级按照`sstatus`的SPP字段设置为U或者S
- CPU会跳转到`sepc`寄存器指向的那条指令，然后继续执行

### 软件功能

#### 用户栈与内核栈

使用两个不同的栈主要是为了安全性：如果两个控制流（即应用程序的控制流和内核的控制流）使用同一个栈，在返回之后应用程序就能读到 Trap 控制流的历史信息，比如内核一些函数的地址，这样会带来安全隐患。于是，我们要做的是，在批处理操作系统中添加一段汇编代码，实现从用户栈切换到内核栈，并在内核栈上保存应用程序控制流的寄存器状态